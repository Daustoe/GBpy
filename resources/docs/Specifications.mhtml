From: <Saved by Blink>
Snapshot-Content-Location: http://bgb.bircd.org/pandocs.htm
Subject: Specifications
Date: Mon, 1 Jun 2020 20:51:20 -0000
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----MultipartBoundary--ewUgoYUz5435X0uE3WhRz0o2tZr2o3Hg3oXqlvE3c5----"


------MultipartBoundary--ewUgoYUz5435X0uE3WhRz0o2tZr2o3Hg3oXqlvE3c5----
Content-Type: text/html
Content-ID: <frame-AFC52E5D8E3B264D4FE746C2F6BA94CD@mhtml.blink>
Content-Transfer-Encoding: quoted-printable
Content-Location: http://bgb.bircd.org/pandocs.htm

<html><head><meta http-equiv=3D"Content-Type" content=3D"text/html; charset=
=3DUTF-8">
  <title>Specifications</title>
  <meta name=3D"GENERATOR" content=3D"nocash XED2HTM converter">
</head><body bgcolor=3D"#ffffff" text=3D"#000000" link=3D"#0033cc" vlink=3D=
"#0033cc" alink=3D"#0033cc">
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"pandocs=
"></a><font size=3D"+2">&nbsp;Pan Docs</font></td></tr></tbody></table><br>
<b>Overview<br>
</b><a href=3D"http://bgb.bircd.org/pandocs.htm#aboutthepandocs">About the =
Pan Docs</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#gameboytechnicaldata">Game Boy =
Technical Data</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#memorymap">Memory Map</a><br>
<br>
<b>I/O Ports<br>
</b><a href=3D"http://bgb.bircd.org/pandocs.htm#videodisplay">Video Display=
</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#soundcontroller">Sound Controll=
er</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#joypadinput">Joypad Input</a><b=
r>
<a href=3D"http://bgb.bircd.org/pandocs.htm#serialdatatransferlinkcable">Se=
rial Data Transfer (Link Cable)</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#timeranddividerregisters">Timer=
 and Divider Registers</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#interrupts">Interrupts</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#cgbregisters">CGB Registers</a>=
<br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#sgbfunctions">SGB Functions</a>=
<br>
<br>
<b>CPU Specifications<br>
</b><a href=3D"http://bgb.bircd.org/pandocs.htm#cpuregistersandflags">CPU R=
egisters and Flags</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#cpuinstructionset">CPU Instruct=
ion Set</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#cpucomparisionwithz80">CPU Comp=
arision with Z80</a><br>
<br>
<b>Cartridges<br>
</b><a href=3D"http://bgb.bircd.org/pandocs.htm#thecartridgeheader">The Car=
tridge Header</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#memorybankcontrollers">Memory B=
ank Controllers</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#gamegeniesharkcheats">Gamegenie=
/Shark Cheats</a><br>
<br>
<b>Other<br>
</b><a href=3D"http://bgb.bircd.org/pandocs.htm#powerupsequence">Power Up S=
equence</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#reducingpowerconsumption">Reduc=
ing Power Consumption</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#spriterambug">Sprite RAM Bug</a=
><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#externalconnectors">External Co=
nnectors</a><br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"aboutth=
epandocs"></a><font size=3D"+2">&nbsp;About the Pan Docs</font></td></tr></=
tbody></table><br>
<table><tbody><tr><td><pre> =3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
       Everything You Always Wanted To Know About GAMEBOY *
 =3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
</pre></td></tr></tbody></table><br>
<table><tbody><tr><td><pre>                     * but were afraid to ask
</pre></td></tr></tbody></table><br>
<table><tbody><tr><td><pre>        Pan of -ATX- Document Updated by contrib=
utions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth
</pre></td></tr></tbody></table><br>
<table><tbody><tr><td><pre>                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa
</pre></td></tr></tbody></table><br>
<b>Forward<br>
</b>The following was typed up for informational purposes regarding the=20
inner workings on the hand-held game machine known as GameBoy,=20
manufactured and designed by Nintendo Co., LTD. This info is presented=20
to inform a user on how their Game Boy works and what makes it "tick".=20
GameBoy is copyrighted by Nintendo Co., LTD. Any reference to=20
copyrighted material is not presented for monetary gain, but for=20
educational purposes and higher learning.<br>
<br>
<b>Available Document Formats<br>
</b>The present version of this document is available in Text and Html form=
at:<br>
<table><tbody><tr><td><pre>  http://www.work.de/nocash/pandocs.txt
  http://www.work.de/nocash/pandocs.htm
</pre></td></tr></tbody></table>Also, a copy of this document is included i=
n the manual of newer=20
versions of the no$gmb debugger, because of recent piracy attacks (many=20
thanks and best wishes go to hell) I have currently no intention to=20
publish any such or further no$gmb updates though.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"gameboy=
technicaldata"></a><font size=3D"+2">&nbsp;Game Boy Technical Data</font></=
td></tr></tbody></table><br>
<table><tbody><tr><td><pre>  CPU          - 8-bit (Similar to the Z80 proce=
ssor)
  Clock Speed  - 4.194304MHz (4.295454MHz for SGB, max. 8.4MHz for CGB)
  Work RAM     - 8K Byte (32K Byte for CGB)
  Video RAM    - 8K Byte (16K Byte for CGB)
  Screen Size  - 2.6"
  Resolution   - 160x144 (20x18 tiles)
  Max sprites  - Max 40 per screen, 10 per line
  Sprite sizes - 8x8 or 8x16
  Palettes     - 1x4 BG, 2x3 OBJ (for CGB: 8x4 BG, 8x3 OBJ)
  Colors       - 4 grayshades (32768 colors for CGB)
  Horiz Sync   - 9198 KHz (9420 KHz for SGB)
  Vert Sync    - 59.73 Hz (61.17 Hz for SGB)
  Sound        - 4 channels with stereo sound
  Power        - DC6V 0.7W (DC3V 0.7W for GB Pocket, DC3V 0.6W for CGB)
</pre></td></tr></tbody></table><br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"memorym=
ap"></a><font size=3D"+2">&nbsp;Memory Map</font></td></tr></tbody></table>=
<br>
The gameboy is having a 16bit address bus, that is used to address ROM,=20
RAM, and I/O registers.<br>
<br>
<b>General Memory Map<br>
</b><table><tbody><tr><td><pre>  0000-3FFF   16KB ROM Bank 00     (in cartr=
idge, fixed at bank 00)
  4000-7FFF   16KB ROM Bank 01..NN (in cartridge, switchable bank number)
  8000-9FFF   8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
  A000-BFFF   8KB External RAM     (in cartridge, switchable bank, if any)
  C000-CFFF   4KB Work RAM Bank 0 (WRAM)
  D000-DFFF   4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
  E000-FDFF   Same as C000-DDFF (ECHO)    (typically not used)
  FE00-FE9F   Sprite Attribute Table (OAM)
  FEA0-FEFF   Not Usable
  FF00-FF7F   I/O Ports
  FF80-FFFE   High RAM (HRAM)
  FFFF        Interrupt Enable Register
</pre></td></tr></tbody></table><br>
<b>Jump Vectors in First ROM Bank<br>
</b>The following addresses are supposed to be used as jump vectors:<br>
<table><tbody><tr><td><pre>  0000,0008,0010,0018,0020,0028,0030,0038   for =
RST commands
  0040,0048,0050,0058,0060                  for Interrupts
</pre></td></tr></tbody></table>However, the memory may be used for any oth=
er purpose in case that your=20
program doesn't use any (or only some) RST commands or Interrupts. RST=20
commands are 1-byte opcodes that work similiar to CALL opcodes, except=20
that the destination address is fixed.<br>
<br>
<b>Cartridge Header in First ROM Bank<br>
</b>The memory at 0100-014F contains the cartridge header. This area=20
contains information about the program, its entry point, checksums,=20
information about the used MBC chip, the ROM and RAM sizes, etc. Most of=20
the bytes in this area are required to be specified correctly. For more=20
information read the chapter about The Cartridge Header.<br>
<br>
<b>External Memory and Hardware<br>
</b>The areas from 0000-7FFF and A000-BFFF may be used to connect external=
=20
hardware. The first area is typically used to address ROM (read only, of=20
course), cartridges with Memory Bank Controllers (MBCs) are additionally=20
using this area to output data (write only) to the MBC chip. The second=20
area is often used to address external RAM, or to address other external=20
hardware (Real Time Clock, etc). External memory is often battery=20
buffered, and may hold saved game positions and high scrore tables=20
(etc.) even when the gameboy is turned of, or when the cartridge is=20
removed. For specific information read the chapter about Memory Bank=20
Controllers.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"videodi=
splay"></a><font size=3D"+2">&nbsp;Video Display</font></td></tr></tbody></=
table><br>
<b>Video I/O Registers<br>
</b><a href=3D"http://bgb.bircd.org/pandocs.htm#lcdcontrolregister">LCD Con=
trol Register</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#lcdstatusregister">LCD Status R=
egister</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#lcdinterrupts">LCD Interrupts</=
a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#lcdpositionandscrolling">LCD Po=
sition and Scrolling</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#lcdmonochromepalettes">LCD Mono=
chrome Palettes</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#lcdcolorpalettescgbonly">LCD Co=
lor Palettes (CGB only)</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#lcdvrambankcgbonly">LCD VRAM Ba=
nk (CGB only)</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#lcdoamdmatransfers">LCD OAM DMA=
 Transfers</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#lcdvramdmatransferscgbonly">LCD=
 VRAM DMA Transfers (CGB only)</a><br>
<br>
<b>Video Memory<br>
</b><a href=3D"http://bgb.bircd.org/pandocs.htm#vramtiledata">VRAM Tile Dat=
a</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps">VRAM Backgr=
ound Maps</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#vramspriteattributetableoam">VR=
AM Sprite Attribute Table (OAM)</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#accessingvramandoam">Accessing =
VRAM and OAM</a><br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"lcdcont=
rolregister"></a><font size=3D"+2">&nbsp;LCD Control Register</font></td></=
tr></tbody></table><br>
<b>FF40 - LCDC - LCD Control (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 7 - LCD Display Enable             (0=
=3DOff, 1=3DOn)
  Bit 6 - Window Tile Map Display Select (0=3D9800-9BFF, 1=3D9C00-9FFF)
  Bit 5 - Window Display Enable          (0=3DOff, 1=3DOn)
  Bit 4 - BG &amp; Window Tile Data Select   (0=3D8800-97FF, 1=3D8000-8FFF)
  Bit 3 - BG Tile Map Display Select     (0=3D9800-9BFF, 1=3D9C00-9FFF)
  Bit 2 - OBJ (Sprite) Size              (0=3D8x8, 1=3D8x16)
  Bit 1 - OBJ (Sprite) Display Enable    (0=3DOff, 1=3DOn)
  Bit 0 - BG Display (for CGB see below) (0=3DOff, 1=3DOn)
</pre></td></tr></tbody></table><br>
<b>LCDC.7 - LCD Display Enable<br>
</b>CAUTION: Stopping LCD operation (Bit 7 from 1 to 0) may be performed=20
during V-Blank ONLY, disabeling the display outside of the V-Blank=20
period may damage the hardware. This appears to be a serious issue,=20
Nintendo is reported to reject any games that do not follow this rule.<br>
V-blank can be confirmed when the value of LY is greater than or equal=20
to 144. When the display is disabled the screen is blank (white), and=20
VRAM and OAM can be accessed freely.<br>
<br>
--- LCDC.0 has different Meanings depending on Gameboy Type ---<br>
<br>
<b>LCDC.0 - 1) Monochrome Gameboy and SGB: BG Display<br>
</b>When Bit 0 is cleared, the background becomes blank (white). Window and=
=20
Sprites may still be displayed (if enabled in Bit 1 and/or Bit 5).<br>
<br>
<b>LCDC.0 - 2) CGB in CGB Mode: BG and Window Master Priority<br>
</b>When Bit 0 is cleared, the background and window lose their priority -=
=20
the sprites will be always displayed on top of background and window,=20
independently of the priority flags in OAM and BG Map attributes.<br>
<br>
<b>LCDC.0 - 3) CGB in Non CGB Mode: BG and Window Display<br>
</b>When Bit 0 is cleared, both background and window become blank (white),=
=20
ie. the Window Display Bit (Bit 5) is ignored in that case. Only Sprites=20
may still be displayed (if enabled in Bit 1).<br>
This is a possible compatibility problem - any monochrome games (if any)=20
that disable the background, but still want to display the window=20
wouldn't work properly on CGBs.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"lcdstat=
usregister"></a><font size=3D"+2">&nbsp;LCD Status Register</font></td></tr=
></tbody></table><br>
<b>FF41 - STAT - LCDC Status   (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 6 - LYC=3DLY Coincidence Interrupt (1=
=3DEnable) (Read/Write)
  Bit 5 - Mode 2 OAM Interrupt         (1=3DEnable) (Read/Write)
  Bit 4 - Mode 1 V-Blank Interrupt     (1=3DEnable) (Read/Write)
  Bit 3 - Mode 0 H-Blank Interrupt     (1=3DEnable) (Read/Write)
  Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=3DLY) (Read Only)
  Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
            0: During H-Blank
            1: During V-Blank
            2: During Searching OAM-RAM
            3: During Transfering Data to LCD Driver
</pre></td></tr></tbody></table><br>
The two lower STAT bits show the current status of the LCD controller.<br>
<table><tbody><tr><td><pre>  Mode 0: The LCD controller is in the H-Blank p=
eriod and
          the CPU can access both the display RAM (8000h-9FFFh)
          and OAM (FE00h-FE9Fh)
</pre></td></tr></tbody></table><br>
<table><tbody><tr><td><pre>  Mode 1: The LCD contoller is in the V-Blank pe=
riod (or the
          display is disabled) and the CPU can access both the
          display RAM (8000h-9FFFh) and OAM (FE00h-FE9Fh)
</pre></td></tr></tbody></table><br>
<table><tbody><tr><td><pre>  Mode 2: The LCD controller is reading from OAM=
 memory.
          The CPU &lt;cannot&gt; access OAM memory (FE00h-FE9Fh)
          during this period.
</pre></td></tr></tbody></table><br>
<table><tbody><tr><td><pre>  Mode 3: The LCD controller is reading from bot=
h OAM and VRAM,
          The CPU &lt;cannot&gt; access OAM and VRAM during this period.
          CGB Mode: Cannot access Palette Data (FF69,FF6B) either.
</pre></td></tr></tbody></table><br>
The following are typical when the display is enabled:<br>
<table><tbody><tr><td><pre>  Mode 2  2_____2_____2_____2_____2_____2_______=
____________2____
  Mode 3  _33____33____33____33____33____33__________________3___
  Mode 0  ___000___000___000___000___000___000________________000
  Mode 1  ____________________________________11111111111111_____
</pre></td></tr></tbody></table><br>
The Mode Flag goes through the values 0, 2, and 3 at a cycle of about=20
109uS. 0 is present about 48.6uS, 2 about 19uS, and 3 about 41uS. This=20
is interrupted every 16.6ms by the VBlank (1). The mode flag stays set=20
at 1 for about 1.08 ms.<br>
<br>
Mode 0 is present between 201-207 clks, 2 about 77-83 clks, and 3 about=20
169-175 clks. A complete cycle through these states takes 456 clks.=20
VBlank lasts 4560 clks. A complete screen refresh occurs every 70224=20
clks.)<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"lcdinte=
rrupts"></a><font size=3D"+2">&nbsp;LCD Interrupts</font></td></tr></tbody>=
</table><br>
<b>INT 40 - V-Blank Interrupt<br>
</b>The V-Blank interrupt occurs ca. 59.7 times a second on a regular GB an=
d=20
ca. 61.1 times a second on a Super GB (SGB). This interrupt occurs at=20
the beginning of the V-Blank period (LY=3D144).<br>
During this period video hardware is not using video ram so it may be=20
freely accessed. This period lasts approximately 1.1 milliseconds.<br>
<br>
<b>INT 48 - LCDC Status Interrupt<br>
</b>There are various reasons for this interrupt to occur as described by=
=20
the STAT register ($FF40). One very popular reason is to indicate to the=20
user when the video hardware is about to redraw a given LCD line. This=20
can be useful for dynamically controlling the SCX/SCY registers=20
($FF43/$FF42) to perform special video effects.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"lcdposi=
tionandscrolling"></a><font size=3D"+2">&nbsp;LCD Position and Scrolling</f=
ont></td></tr></tbody></table><br>
<b>FF42 - SCY - Scroll Y   (R/W)<br>
FF43 - SCX - Scroll X   (R/W)<br>
</b>Specifies the position in the 256x256 pixels BG map (32x32 tiles) which=
=20
is to be displayed at the upper/left LCD display position.<br>
Values in range from 0-255 may be used for X/Y each, the video=20
controller automatically wraps back to the upper (left) position in BG=20
map when drawing exceeds the lower (right) border of the BG map area.<br>
<br>
<b>FF44 - LY - LCDC Y-Coordinate (R)<br>
</b>The LY indicates the vertical line to which the present data is=20
transferred to the LCD Driver. The LY can take on any value between 0=20
through 153. The values between 144 and 153 indicate the V-Blank period.=20
Writing will reset the counter.<br>
<br>
<b>FF45 - LYC - LY Compare  (R/W)<br>
</b>The gameboy permanently compares the value of the LYC and LY registers.=
=20
When both values are identical, the coincident bit in the STAT register=20
becomes set, and (if enabled) a STAT interrupt is requested.<br>
<br>
<b>FF4A - WY - Window Y Position (R/W)<br>
FF4B - WX - Window X Position minus 7 (R/W)<br>
</b>Specifies the upper/left positions of the Window area. (The window is a=
n=20
alternate background area which can be displayed above of the normal=20
background. OBJs (sprites) may be still displayed above or behinf the=20
window, just as for normal BG.)<br>
The window becomes visible (if enabled) when positions are set in range=20
WX=3D0..166, WY=3D0..143. A postion of WX=3D7, WY=3D0 locates the window at=
=20
upper left, it is then completly covering normal background.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"lcdmono=
chromepalettes"></a><font size=3D"+2">&nbsp;LCD Monochrome Palettes</font><=
/td></tr></tbody></table><br>
<b>FF47 - BGP - BG Palette Data  (R/W) - Non CGB Mode Only<br>
</b>This register assigns gray shades to the color numbers of the BG and=20
Window tiles.<br>
<table><tbody><tr><td><pre>  Bit 7-6 - Shade for Color Number 3
  Bit 5-4 - Shade for Color Number 2
  Bit 3-2 - Shade for Color Number 1
  Bit 1-0 - Shade for Color Number 0
</pre></td></tr></tbody></table>The four possible gray shades are:<br>
<table><tbody><tr><td><pre>  0  White
  1  Light gray
  2  Dark gray
  3  Black
</pre></td></tr></tbody></table>In CGB Mode the Color Palettes are taken fr=
om CGB Palette Memory=20
instead.<br>
<br>
<b>FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only<br>
</b>This register assigns gray shades for sprite palette 0. It works exactl=
y=20
as BGP (FF47), except that the lower two bits aren't used because sprite=20
data 00 is transparent.<br>
<br>
<b>FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only<br>
</b>This register assigns gray shades for sprite palette 1. It works exactl=
y=20
as BGP (FF47), except that the lower two bits aren't used because sprite=20
data 00 is transparent.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"lcdcolo=
rpalettescgbonly"></a><font size=3D"+2">&nbsp;LCD Color Palettes (CGB only)=
</font></td></tr></tbody></table><br>
<b>FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index<br>
</b>This register is used to address a byte in the CGBs Background Palette=
=20
Memory. Each two byte in that memory define a color value. The first 8=20
bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.<br>
<table><tbody><tr><td><pre>  Bit 0-5   Index (00-3F)
  Bit 7     Auto Increment  (0=3DDisabled, 1=3DIncrement after Writing)
</pre></td></tr></tbody></table>Data can be read/written to/from the specif=
ied index address through=20
Register FF69. When the Auto Increment Bit is set then the index is=20
automatically incremented after each &lt;write&gt; to FF69. Auto Increment =
has=20
no effect when &lt;reading&gt; from FF69, so the index must be manually=20
incremented in that case.<br>
<br>
<b>FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data<br>
</b>This register allows to read/write data to the CGBs Background Palette=
=20
Memory, addressed through Register FF68.<br>
Each color is defined by two bytes (Bit 0-7 in first byte).<br>
<table><tbody><tr><td><pre>  Bit 0-4   Red Intensity   (00-1F)
  Bit 5-9   Green Intensity (00-1F)
  Bit 10-14 Blue Intensity  (00-1F)
</pre></td></tr></tbody></table>Much like VRAM, Data in Palette Memory cann=
ot be read/written during the=20
time when the LCD Controller is reading from it. (That is when the STAT=20
register indicates Mode 3).<br>
Note: Initially all background colors are initialized as white.<br>
<br>
<b>FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index<br>
FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data<br>
</b>These registers are used to initialize the Sprite Palettes OBP0-7,=20
identically as described above for Background Palettes. Note that four=20
colors may be defined for each OBP Palettes - but only Color 1-3 of each=20
Sprite Palette can be displayed, Color 0 is always transparent, and can=20
be initialized to a don't care value.<br>
Note: Initially all sprite colors are uninitialized.<br>
<br>
<b>RGB Translation by CGBs<br>
</b>When developing graphics on PCs, note that the RGB values will have=20
different appearance on CGB displays as on VGA monitors:<br>
The highest intensity will produce Light Gray color rather than White.=20
The intensities are not linear; the values 10h-1Fh will all appear very=20
bright, while medium and darker colors are ranged at 00h-0Fh.<br>
The CGB display will mix colors quite oddly, increasing intensity of=20
only one R,G,B color will also influence the other two R,G,B colors.<br>
For example, a color setting of 03EFh (Blue=3D0, Green=3D1Fh, Red=3D0Fh) wi=
ll=20
appear as Neon Green on VGA displays, but on the CGB it'll produce a=20
decently washed out Yellow.<br>
<br>
<b>RGB Translation by GBAs<br>
</b>Even though GBA is described to be compatible to CGB games, most CGB=20
games are completely unplayable on GBAs because most colors are=20
invisible (black). Of course, colors such like Black and White will=20
appear the same on both CGB and GBA, but medium intensities are arranged=20
completely different.<br>
Intensities in range 00h..0Fh are invisible/black (unless eventually=20
under best sunlight circumstances, and when gazing at the screen under=20
obscure viewing angles), unfortunately, these intensities are regulary=20
used by most existing CGB games for medium and darker colors.<br>
Newer CGB games may avoid this effect by changing palette data when=20
detecting GBA hardware. A relative simple method would be using the=20
formula GBA=3DCGB/2+10h for each R,G,B intensity, probably the result=20
won't be perfect, and (once colors became visible) it may turn out that=20
the color mixing is different also, anyways, it'd be still ways better=20
than no conversion.<br>
Asides, this translation method should have been VERY easy to implement=20
in GBA hardware directly, even though Nintendo obviously failed to do=20
so. How did they say, This seal is your assurance for excellence in=20
workmanship and so on?<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"lcdvram=
bankcgbonly"></a><font size=3D"+2">&nbsp;LCD VRAM Bank (CGB only)</font></t=
d></tr></tbody></table><br>
<b>FF4F - VBK - CGB Mode Only - VRAM Bank<br>
</b>This 1bit register selects the current Video Memory (VRAM) Bank.<br>
<table><tbody><tr><td><pre>  Bit 0 - VRAM Bank (0-1)
</pre></td></tr></tbody></table>Bank 0 contains 192 Tiles, and two backgrou=
nd maps, just as for=20
monochrome games. Bank 1 contains another 192 Tiles, and color attribute=20
maps for the background maps in bank 0.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"lcdoamd=
matransfers"></a><font size=3D"+2">&nbsp;LCD OAM DMA Transfers</font></td><=
/tr></tbody></table><br>
<b>FF46 - DMA - DMA Transfer and Start Address (W)<br>
</b>Writing to this register launches a DMA transfer from ROM or RAM to OAM=
=20
memory (sprite attribute table). The written value specifies the=20
transfer source address divided by 100h, ie. source &amp; destination are:<=
br>
<table><tbody><tr><td><pre>  Source:      XX00-XX9F   ;XX in range from 00-=
F1h
  Destination: FE00-FE9F
</pre></td></tr></tbody></table>It takes 160 microseconds until the transfe=
r has completed (80=20
microseconds in CGB Double Speed Mode), during this time the CPU can=20
access only HRAM (memory at FF80-FFFE). For this reason, the programmer=20
must copy a short procedure into HRAM, and use this procedure to start=20
the transfer from inside HRAM, and wait until the transfer has finished:<br=
>
<table><tbody><tr><td><pre>   ld  (0FF46h),a ;start DMA transfer, a=3Dstart=
 address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
</pre></td></tr></tbody></table>Most programs are executing this procedure =
from inside of their VBlank=20
procedure, but it is possible to execute it during display redraw also,=20
allowing to display more than 40 sprites on the screen (ie. for example=20
40 sprites in upper half, and other 40 sprites in lower half of the=20
screen).<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"lcdvram=
dmatransferscgbonly"></a><font size=3D"+2">&nbsp;LCD VRAM DMA Transfers (CG=
B only)</font></td></tr></tbody></table><br>
<b>FF51 - HDMA1 - CGB Mode Only - New DMA Source, High<br>
FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low<br>
FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High<br>
FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low<br>
FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start<br>
</b>These registers are used to initiate a DMA transfer from ROM or RAM to=
=20
VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0,=20
the lower four bits of the address are ignored (treated as zero). The=20
Destination Start Address may be located at 8000-9FF0, the lower four=20
bits of the address are ignored (treated as zero), the upper 3 bits are=20
ignored either (destination is always in VRAM).<br>
<br>
Writing to FF55 starts the transfer, the lower 7 bits of FF55 specify=20
the Transfer Length (divided by 10h, minus 1). Ie. lengths of 10h-800h=20
bytes can be defined by the values 00h-7Fh. And the upper bit of FF55=20
indicates the Transfer Mode:<br>
<br>
<b>Bit7=3D0 - General Purpose DMA<br>
</b>When using this transfer method, all data is transferred at once. The=
=20
execution of the program is halted until the transfer has completed.=20
Note that the General Purpose DMA blindly attempts to copy the data,=20
even if the LCD controller is currently accessing VRAM. So General=20
Purpose DMA should be used only if the Display is disabled, or during=20
V-Blank, or (for rather short blocks) during H-Blank.<br>
The execution of the program continues when the transfer has been=20
completed, and FF55 then contains a value if FFh.<br>
<br>
<b>Bit7=3D1 - H-Blank DMA<br>
</b>The H-Blank DMA transfers 10h bytes of data during each H-Blank, ie. at=
=20
LY=3D0-143, no data is transferred during V-Blank (LY=3D144-153), but the=
=20
transfer will then continue at LY=3D00. The execution of the program is=20
halted during the separate transfers, but the program execution=20
continues during the 'spaces' between each data block.<br>
Note that the program may not change the Destination VRAM bank (FF4F),=20
or the Source ROM/RAM bank (in case data is transferred from bankable=20
memory) until the transfer has completed!<br>
Reading from Register FF55 returns the remaining length (divided by 10h,=20
minus 1), a value of 0FFh indicates that the transfer has completed. It=20
is also possible to terminate an active H-Blank transfer by writing zero=20
to Bit 7 of FF55. In that case reading from FF55 may return any value=20
for the lower 7 bits, but Bit 7 will be read as "1".<br>
<br>
<b>Confirming if the DMA Transfer is Active<br>
</b>Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is=20
active (1=3DNot Active, 0=3DActive). This works under any circumstances -=
=20
after completion of General Purpose, or H-Blank Transfer, and after=20
manually terminating a H-Blank Transfer.<br>
<br>
<b>Transfer Timings<br>
</b>In both Normal Speed and Double Speed Mode it takes about 8us to=20
transfer a block of 10h bytes. That are 8 cycles in Normal Speed Mode,=20
and 16 'fast' cycles in Double Speed Mode.<br>
Older MBC controllers (like MBC1-4) and slower ROMs are not guaranteed=20
to support General Purpose or H-Blank DMA, that's because there are=20
always 2 bytes transferred per microsecond (even if the itself program=20
runs it Normal Speed Mode).<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"vramtil=
edata"></a><font size=3D"+2">&nbsp;VRAM Tile Data</font></td></tr></tbody><=
/table><br>
Tile Data is stored in VRAM at addresses 8000h-97FFh, this area defines=20
the Bitmaps for 192 Tiles. In CGB Mode 384 Tiles can be defined, because=20
memory at 0:8000h-97FFh and at 1:8000h-97FFh is used.<br>
<br>
Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray=20
shades. Tiles can be displayed as part of the Background/Window map,=20
and/or as OAM tiles (foreground sprites). Note that foreground sprites=20
may have only 3 colors, because color 0 is transparent.<br>
<br>
As it was said before, there are two Tile Pattern Tables at $8000-8FFF=20
and at $8800-97FF. The first one can be used for sprites and the=20
background. Its tiles are numbered from 0 to 255. The second table can=20
be used for the background and the window display and its tiles are=20
numbered from -128 to 127.<br>
<br>
Each Tile occupies 16 bytes, where each 2 bytes represent a line:<br>
<table><tbody><tr><td><pre>  Byte 0-1  First Line (Upper 8 pixels)
  Byte 2-3  Next Line
  etc.
</pre></td></tr></tbody></table>For each line, the first byte defines the l=
east significant bits of the=20
color numbers for each pixel, and the second byte defines the upper bits=20
of the color numbers. In either case, Bit 7 is the leftmost pixel, and=20
Bit 0 the rightmost.<br>
<br>
So, each pixel is having a color number in range from 0-3. The color=20
numbers are translated into real colors (or gray shades) depending on=20
the current palettes. The palettes are defined through registers=20
FF47-FF49 (Non CGB Mode), and FF68-FF6B (CGB Mode).<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"vrambac=
kgroundmaps"></a><font size=3D"+2">&nbsp;VRAM Background Maps</font></td></=
tr></tbody></table><br>
The gameboy contains two 32x32 tile background maps in VRAM at addresses=20
9800h-9BFFh and 9C00h-9FFFh. Each can be used either to display "normal"=20
background, or "window" background.<br>
<br>
<b>BG Map Tile Numbers<br>
</b>An area of VRAM known as Background Tile Map contains the numbers of=20
tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each=20
byte contains a number of a tile to be displayed. Tile patterns are=20
taken from the Tile Data Table located either at $8000-8FFF or=20
$8800-97FF. In the first case, patterns are numbered with unsigned=20
numbers from 0 to 255 (i.e. pattern #0 lies at address $8000). In the=20
second case, patterns have signed numbers from -128 to 127 (i.e. pattern=20
#0 lies at address $9000). The Tile Data Table address for the=20
background can be selected via LCDC register.<br>
<br>
<b>BG Map Attributes (CGB Mode only)<br>
</b>In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1=
=20
(each byte defines attributes for the corresponding tile-number map=20
entry in VRAM Bank 0):<br>
<table><tbody><tr><td><pre>  Bit 0-2  Background Palette number  (BGP0-7)
  Bit 3    Tile VRAM Bank number      (0=3DBank 0, 1=3DBank 1)
  Bit 4    Not used
  Bit 5    Horizontal Flip            (0=3DNormal, 1=3DMirror horizontally)
  Bit 6    Vertical Flip              (0=3DNormal, 1=3DMirror vertically)
  Bit 7    BG-to-OAM Priority         (0=3DUse OAM priority bit, 1=3DBG Pri=
ority)
</pre></td></tr></tbody></table>When Bit 7 is set, the corresponding BG til=
e will have priority above=20
all OBJs (regardless of the priority bits in OAM memory). There's also=20
an Master Priority flag in LCDC register Bit 0 which overrides all other=20
priority bits when cleared.<br>
<br>
As one background tile has a size of 8x8 pixels, the BG maps may hold a=20
picture of 256x256 pixels, an area of 160x144 pixels of this picture can=20
be displayed on the LCD screen.<br>
<br>
<b>Normal Background (BG)<br>
</b>The SCY and SCX registers can be used to scroll the background, allowin=
g=20
to select the origin of the visible 160x144 pixel area within the total=20
256x256 pixel background map. Background wraps around the screen (i.e.=20
when part of it goes off the screen, it appears on the opposite side.)<br>
<br>
<b>The Window<br>
</b>Besides background, there is also a "window" overlaying the background.=
=20
The window is not scrollable i.e. it is always displayed starting from=20
its left upper corner. The location of a window on the screen can be=20
adjusted via WX and WY registers. Screen coordinates of the top left=20
corner of a window are WX-7,WY. The tiles for the window are stored in=20
the Tile Data Table. Both the Background and the window share the same=20
Tile Data Table.<br>
<br>
Both background and window can be disabled or enabled separately via=20
bits in the LCDC register.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"vramspr=
iteattributetableoam"></a><font size=3D"+2">&nbsp;VRAM Sprite Attribute Tab=
le (OAM)</font></td></tr></tbody></table><br>
GameBoy video controller can display up to 40 sprites either in 8x8 or=20
in 8x16 pixels. Because of a limitation of hardware, only ten sprites=20
can be displayed per scan line. Sprite patterns have the same format as=20
BG tiles, but they are taken from the Sprite Pattern Table located at=20
$8000-8FFF and have unsigned numbering.<br>
<br>
Sprite attributes reside in the Sprite Attribute Table (OAM - Object=20
Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four=20
bytes with the following meanings:<br>
<br>
<b>Byte0 - Y Position<br>
</b>Specifies the sprites vertical position on the screen (minus 16).<br>
An offscreen value (for example, Y=3D0 or Y&gt;=3D160) hides the sprite.<br=
>
<br>
<b>Byte1 - X Position<br>
</b>Specifies the sprites horizontal position on the screen (minus 8).<br>
An offscreen value (X=3D0 or X&gt;=3D168) hides the sprite, but the sprite<=
br>
still affects the priority ordering - a better way to hide a sprite is=20
to set its Y-coordinate offscreen.<br>
<br>
<b>Byte2 - Tile/Pattern Number<br>
</b>Specifies the sprites Tile Number (00-FF). This (unsigned) value select=
s=20
a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in=20
VRAM Bank 0 or 1, depending on Bit 3 of the following byte.<br>
In 8x16 mode, the lower bit of the tile number is ignored. Ie. the upper=20
8x8 tile is "NN AND FEh", and the lower 8x8 tile is "NN OR 01h".<br>
<br>
<b>Byte3 - Attributes/Flags:<br>
</b><table><tbody><tr><td><pre>  Bit7   OBJ-to-BG Priority (0=3DOBJ Above B=
G, 1=3DOBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=3DNormal, 1=3DVertically mirrored)
  Bit5   X flip          (0=3DNormal, 1=3DHorizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=3DOBP0, 1=3DOBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=3DBank 0, 1=3DBank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)
</pre></td></tr></tbody></table><br>
<b>Sprite Priorities and Conflicts<br>
</b>When sprites with different x coordinate values overlap, the one with=
=20
the smaller x coordinate (closer to the left) will have priority and=20
appear above any others. This applies in Non CGB Mode only.<br>
When sprites with the same x coordinate values overlap, they have=20
priority according to table ordering. (i.e. $FE00 - highest, $FE04 -=20
next highest, etc.) In CGB Mode priorities are always assigned like=20
this.<br>
<br>
Only 10 sprites can be displayed on any one line. When this limit is=20
exceeded, the lower priority sprites (priorities listed above) won't be=20
displayed. To keep unused sprites from affecting onscreen sprites set=20
their Y coordinate to Y=3D0 or Y=3D&gt;144+16. Just setting the X coordinat=
e to=20
X=3D0 or X=3D&gt;160+8 on a sprite will hide it but it will still affect ot=
her=20
sprites sharing the same lines.<br>
<br>
<b>Writing Data to OAM Memory<br>
</b>The recommened method is to write the data to normal RAM first, and to=
=20
copy that RAM to OAM by using the DMA transfer function, initiated=20
through DMA register (FF46).<br>
Beside for that, it is also possible to write data directly to the OAM=20
area by using normal LD commands, this works only during the H-Blank and=20
V-Blank periods. The current state of the LCD controller can be read out=20
from the STAT register (FF41).<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"accessi=
ngvramandoam"></a><font size=3D"+2">&nbsp;Accessing VRAM and OAM</font></td=
></tr></tbody></table><br>
<b>CAUTION<br>
</b>When the LCD Controller is drawing the screen it is directly reading=20
from Video Memory (VRAM) and from the Sprite Attribute Table (OAM).=20
During these periods the Gameboy CPU may not access the VRAM and OAM.=20
That means, any attempts to write to VRAM/OAM are ignored (the data=20
remains unchanged). And any attempts to read from VRAM/OAM will return=20
undefined data (typically a value of FFh).<br>
<br>
For this reason the program should verify if VRAM/OAM is accessable=20
before actually reading or writing to it. This is usually done by=20
reading the Mode Bits from the STAT Register (FF41). When doing this (as=20
described in the examples below) you should take care that no interrupts=20
occur between the wait loops and the following memory access - the=20
memory is guaranted to be accessable only for a few cycles directly=20
after the wait loops have completed.<br>
<br>
<b>VRAM (memory at 8000h-9FFFh) is accessable during Mode 0-2<br>
</b><table><tbody><tr><td><pre>  Mode 0 - H-Blank Period,
  Mode 1 - V-Blank Period, and
  Mode 2 - Searching OAM Period
</pre></td></tr></tbody></table>A typical procedure that waits for accessib=
ility of VRAM would be:<br>
<table><tbody><tr><td><pre>  ld   hl,0FF41h    ;-STAT Register
 @@wait:            ;\
  bit  1,(hl)       ; Wait until Mode is 0 or 1
  jr   nz,@@wait    ;/
</pre></td></tr></tbody></table>Even if the procedure gets executed at the =
&lt;end&gt; of Mode 0 or 1, it is=20
still proof to assume that VRAM can be accessed for a few more cycles=20
because in either case the following period is Mode 2 which allows=20
access to VRAM either.<br>
In CGB Mode an alternate method to write data to VRAM is to use the HDMA=20
Function (FF51-FF55).<br>
<br>
<b>OAM (memory at FE00h-FE9Fh) is accessable during Mode 0-1<br>
</b><table><tbody><tr><td><pre>  Mode 0 - H-Blank Period, and
  Mode 1 - V-Blank Period
</pre></td></tr></tbody></table>Beside for that, OAM can be accessed at any=
 time by using the DMA=20
Function (FF46). When directly reading or writing to OAM, a typical=20
procedure that waits for accessibilty or OAM Memory would be:<br>
<table><tbody><tr><td><pre>  ld   hl,0FF41h    ;-STAT Register
 @@wait1:           ;\
  bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
  jr   nz,@@wait2   ;/
</pre></td></tr></tbody></table>The two wait loops ensure that Mode 0 or 1 =
will last for a few clock=20
cycles after completion of the procedure. In V-Blank period it might be=20
recommended to skip the whole procedure - and in most cases using the=20
above mentioned DMA function would be more recommended anyways.<br>
<br>
<b>Note<br>
</b>When the display is disabled, both VRAM and OAM are accessable at any=
=20
time. The downside is that the screen is blank (white) during this=20
period, so that disabling the display would be recommended only during=20
initialization.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"soundco=
ntroller"></a><font size=3D"+2">&nbsp;Sound Controller</font></td></tr></tb=
ody></table><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#soundoverview">Sound Overview</=
a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#soundchannel1tonesweep">Sound C=
hannel 1 - Tone &amp; Sweep</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#soundchannel2tone">Sound Channe=
l 2 - Tone</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#soundchannel3waveoutput">Sound =
Channel 3 - Wave Output</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#soundchannel4noise">Sound Chann=
el 4 - Noise</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#soundcontrolregisters">Sound Co=
ntrol Registers</a><br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"soundov=
erview"></a><font size=3D"+2">&nbsp;Sound Overview</font></td></tr></tbody>=
</table><br>
There are two sound channels connected to the output terminals SO1 and=20
SO2. There is also a input terminal Vin connected to the cartridge. It=20
can be routed to either of both output terminals. GameBoy circuitry=20
allows producing sound in four different ways:<br>
<br>
<table><tbody><tr><td><pre>   Quadrangular wave patterns with sweep and env=
elope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.
</pre></td></tr></tbody></table><br>
These four sounds can be controlled independantly and then mixed=20
separately for each of the output terminals.<br>
<br>
Sound registers may be set at all times while producing sound.<br>
<br>
(Sounds will have a 2.4% higher frequency on Super GB.)<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"soundch=
annel1tonesweep"></a><font size=3D"+2">&nbsp;Sound Channel 1 - Tone &amp; S=
weep</font></td></tr></tbody></table><br>
<b>FF10 - NR10 - Channel 1 Sweep register (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)
</pre></td></tr></tbody></table>Sweep Time:<br>
<table><tbody><tr><td><pre>  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)
</pre></td></tr></tbody></table><br>
The change of frequency (NR13,NR14) at each shift is calculated by the=20
following formula where X(0) is initial freq &amp; X(t-1) is last freq:<br>
<table><tbody><tr><td><pre>  X(t) =3D X(t-1) +/- X(t-1)/2^n
</pre></td></tr></tbody></table><br>
<b>FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)
</pre></td></tr></tbody></table>Wave Duty:<br>
<table><tbody><tr><td><pre>  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )
</pre></td></tr></tbody></table>Sound Length =3D (64-t1)*(1/256) seconds<br=
>
The Length value is used only if Bit 6 in NR14 is set.<br>
<br>
<b>FF12 - NR12 - Channel 1 Volume Envelope (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 7-4 - Initial Volume of envelope (0-0F=
h) (0=3DNo Sound)
  Bit 3   - Envelope Direction (0=3DDecrease, 1=3DIncrease)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)
</pre></td></tr></tbody></table>Length of 1 step =3D n*(1/64) seconds<br>
<br>
<b>FF13 - NR13 - Channel 1 Frequency lo (Write Only)<br>
</b><br>
Lower 8 bits of 11 bit frequency (x).<br>
Next 3 bit are in NR14 ($FF14)<br>
<br>
<b>FF14 - NR14 - Channel 1 Frequency hi (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 7   - Initial (1=3DRestart Sound)     =
(Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=3DStop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)
</pre></td></tr></tbody></table>Frequency =3D 131072/(2048-x) Hz<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"soundch=
annel2tone"></a><font size=3D"+2">&nbsp;Sound Channel 2 - Tone</font></td><=
/tr></tbody></table><br>
This sound channel works exactly as channel 1, except that it doesn't=20
have a Tone Envelope/Sweep Register.<br>
<br>
<b>FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)
</pre></td></tr></tbody></table>Wave Duty:<br>
<table><tbody><tr><td><pre>  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )
</pre></td></tr></tbody></table>Sound Length =3D (64-t1)*(1/256) seconds<br=
>
The Length value is used only if Bit 6 in NR24 is set.<br>
<br>
<b>FF17 - NR22 - Channel 2 Volume Envelope (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 7-4 - Initial Volume of envelope (0-0F=
h) (0=3DNo Sound)
  Bit 3   - Envelope Direction (0=3DDecrease, 1=3DIncrease)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)
</pre></td></tr></tbody></table>Length of 1 step =3D n*(1/64) seconds<br>
<br>
<b>FF18 - NR23 - Channel 2 Frequency lo data (W)<br>
</b>Frequency's lower 8 bits of 11 bit data (x).<br>
Next 3 bits are in NR24 ($FF19).<br>
<br>
<b>FF19 - NR24 - Channel 2 Frequency hi data (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 7   - Initial (1=3DRestart Sound)     =
(Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=3DStop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)
</pre></td></tr></tbody></table>Frequency =3D 131072/(2048-x) Hz<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"soundch=
annel3waveoutput"></a><font size=3D"+2">&nbsp;Sound Channel 3 - Wave Output=
</font></td></tr></tbody></table><br>
This channel can be used to output digital sound, the length of the=20
sample buffer (Wave RAM) is limited to 32 digits. This sound channel can=20
be also used to output normal tones when initializing the Wave RAM by a=20
square wave. This channel doesn't have a volume envelope register.<br>
<br>
<b>FF1A - NR30 - Channel 3 Sound on/off (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 7 - Sound Channel 3 Off  (0=3DStop, 1=
=3DPlayback)  (Read/Write)
</pre></td></tr></tbody></table><br>
<b>FF1B - NR31 - Channel 3 Sound Length<br>
</b><table><tbody><tr><td><pre>  Bit 7-0 - Sound length (t1: 0 - 255)
</pre></td></tr></tbody></table>Sound Length =3D (256-t1)*(1/256) seconds<b=
r>
This value is used only if Bit 6 in NR34 is set.<br>
<br>
<b>FF1C - NR32 - Channel 3 Select output level (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 6-5 - Select output level (Read/Write)
</pre></td></tr></tbody></table>Possible Output levels are:<br>
<table><tbody><tr><td><pre>  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)
</pre></td></tr></tbody></table><br>
<b>FF1D - NR33 - Channel 3 Frequency's lower data (W)<br>
</b>Lower 8 bits of an 11 bit frequency (x).<br>
<br>
<b>FF1E - NR34 - Channel 3 Frequency's higher data (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 7   - Initial (1=3DRestart Sound)     =
(Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=3DStop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)
</pre></td></tr></tbody></table>Frequency  =3D  4194304/(64*(2048-x)) Hz  =
=3D  65536/(2048-x) Hz<br>
<br>
<b>FF30-FF3F - Wave Pattern RAM<br>
</b>Contents - Waveform storage for arbitrary sound data<br>
<br>
This storage area holds 32 4-bit samples  that are played back upper 4=20
bits first.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"soundch=
annel4noise"></a><font size=3D"+2">&nbsp;Sound Channel 4 - Noise</font></td=
></tr></tbody></table><br>
This channel is used to output white noise. This is done by randomly=20
switching the amplitude between high and low at a given frequency.=20
Depending on the frequency the noise will appear 'harder' or 'softer'.<br>
<br>
It is also possible to influence the function of the random generator,=20
so the that the output becomes more regular, resulting in a limited=20
ability to output Tone instead of Noise.<br>
<br>
<b>FF20 - NR41 - Channel 4 Sound Length (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 5-0 - Sound length data (t1: 0-63)
</pre></td></tr></tbody></table>Sound Length =3D (64-t1)*(1/256) seconds<br=
>
The Length value is used only if Bit 6 in NR44 is set.<br>
<br>
<b>FF21 - NR42 - Channel 4 Volume Envelope (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 7-4 - Initial Volume of envelope (0-0F=
h) (0=3DNo Sound)
  Bit 3   - Envelope Direction (0=3DDecrease, 1=3DIncrease)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)
</pre></td></tr></tbody></table>Length of 1 step =3D n*(1/64) seconds<br>
<br>
<b>FF22 - NR43 - Channel 4 Polynomial Counter (R/W)<br>
</b>The amplitude is randomly switched between high and low at the given=20
frequency. A higher frequency will make the noise to appear 'softer'.<br>
When Bit 3 is set, the output will become more regular, and some=20
frequencies will sound more like Tone than Noise.<br>
<table><tbody><tr><td><pre>  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=3D15 bits, 1=3D7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)
</pre></td></tr></tbody></table>Frequency =3D 524288 Hz / r / 2^(s+1)     ;=
For r=3D0 assume r=3D0.5 instead<br>
<br>
<b>FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 7   - Initial (1=3DRestart Sound)     =
(Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=3DStop output when length in NR41 expires)
</pre></td></tr></tbody></table><br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"soundco=
ntrolregisters"></a><font size=3D"+2">&nbsp;Sound Control Registers</font><=
/td></tr></tbody></table><br>
<b>FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)<br>
</b>The volume bits specify the "Master Volume" for Left/Right sound output=
.<br>
<table><tbody><tr><td><pre>  Bit 7   - Output Vin to SO2 terminal (1=3DEnab=
le)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=3DEnable)
  Bit 2-0 - SO1 output level (volume)  (0-7)
</pre></td></tr></tbody></table>The Vin signal is received from the game ca=
rtridge bus, allowing=20
external hardware in the cartridge to supply a fifth sound channel,=20
additionally to the gameboys internal four channels. As far as I know=20
this feature isn't used by any existing games.<br>
<br>
<b>FF25 - NR51 - Selection of Sound output terminal (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal
</pre></td></tr></tbody></table><br>
<b>FF26 - NR52 - Sound on/off<br>
</b>If your GB programs don't use sound then write 00h to this register to=
=20
save 16% or more on GB power consumption. Disabeling the sound=20
controller by clearing Bit 7 destroys the contents of all sound=20
registers. Also, it is not possible to access any sound registers=20
(execpt FF26) while the sound controller is disabled.<br>
<table><tbody><tr><td><pre>  Bit 7 - All sound on/off  (0: stop all sound c=
ircuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)
</pre></td></tr></tbody></table>Bits 0-3 of this register are read only sta=
tus bits, writing to these=20
bits does NOT enable/disable sound. The flags get set when sound output=20
is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag=20
remains set until the sound length has expired (if enabled). A volume=20
envelopes which has decreased to zero volume will NOT cause the sound=20
flag to go off.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"joypadi=
nput"></a><font size=3D"+2">&nbsp;Joypad Input</font></td></tr></tbody></ta=
ble><br>
<b>FF00 - P1/JOYP - Joypad (R/W)<br>
</b>The eight gameboy buttons/direction keys are arranged in form of a 2x4=
=20
matrix. Select either button or direction keys by writing to this=20
register, then read-out bit 0-3.<br>
<table><tbody><tr><td><pre>  Bit 7 - Not used
  Bit 6 - Not used
  Bit 5 - P15 Select Button Keys      (0=3DSelect)
  Bit 4 - P14 Select Direction Keys   (0=3DSelect)
  Bit 3 - P13 Input Down  or Start    (0=3DPressed) (Read Only)
  Bit 2 - P12 Input Up    or Select   (0=3DPressed) (Read Only)
  Bit 1 - P11 Input Left  or Button B (0=3DPressed) (Read Only)
  Bit 0 - P10 Input Right or Button A (0=3DPressed) (Read Only)
</pre></td></tr></tbody></table>Note: Most programs are repeatedly reading =
from this port several times=20
(the first reads used as short delay, allowing the inputs to stabilize,=20
and only the value from the last read actually used).<br>
<br>
<b>Usage in SGB software<br>
</b>Beside for normal joypad input, SGB games mis-use the joypad register t=
o=20
output SGB command packets to the SNES, also, SGB programs may read out=20
gamepad states from up to four different joypads which can be connected=20
to the SNES.<br>
See SGB description for details.<br>
<br>
<b>INT 60 - Joypad Interrupt<br>
</b>Joypad interrupt is requested when any of the above Input lines changes=
=20
from High to Low. Generally this should happen when a key becomes=20
pressed (provided that the button/direction key is enabled by above=20
Bit4/5), however, because of switch bounce, one or more High to Low=20
transitions are usually produced both when pressing or releasing a key.<br>
<br>
<b>Using the Joypad Interrupt<br>
</b>It's more or less useless for programmers, even when selecting both=20
buttons and direction keys simultaneously it still cannot recognize all=20
keystrokes, because in that case a bit might be already held low by a=20
button key, and pressing the corresponding direction key would thus=20
cause no difference. The only meaningful purpose of the keystroke=20
interrupt would be to terminate STOP (low power) standby state.<br>
Also, the joypad interrupt does not appear to work with CGB and GBA=20
hardware (the STOP function can be still terminated by joypad keystrokes=20
though).<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"seriald=
atatransferlinkcable"></a><font size=3D"+2">&nbsp;Serial Data Transfer (Lin=
k Cable)</font></td></tr></tbody></table><br>
<b>FF01 - SB - Serial transfer data (R/W)<br>
</b>8 Bits of data to be read/written<br>
<br>
<b>FF02 - SC - Serial Transfer Control  (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 7 - Transfer Start Flag (0=3DNo Transf=
er, 1=3DStart)
  Bit 1 - Clock Speed (0=3DNormal, 1=3DFast) ** CGB Mode Only **
  Bit 0 - Shift Clock (0=3DExternal Clock, 1=3DInternal Clock)
</pre></td></tr></tbody></table>The clock signal specifies the rate at whic=
h the eight data bits in SB=20
(FF01) are transferred. When the gameboy is communicating with another=20
gameboy (or other computer) then either one must supply internal clock,=20
and the other one must use external clock.<br>
<br>
<b>Internal Clock<br>
</b>In Non-CGB Mode the gameboy supplies an internal clock of 8192Hz only=
=20
(allowing to transfer about 1 KByte per second). In CGB Mode four=20
internal clock rates are available, depending on Bit 1 of the SC=20
register, and on whether the CGB Double Speed Mode is used:<br>
<table><tbody><tr><td><pre>    8192Hz -  1KB/s - Bit 1 cleared, Normal
   16384Hz -  2KB/s - Bit 1 cleared, Double Speed Mode
  262144Hz - 32KB/s - Bit 1 set,     Normal
  524288Hz - 64KB/s - Bit 1 set,     Double Speed Mode
</pre></td></tr></tbody></table><br>
<b>External Clock<br>
</b>The external clock is typically supplied by another gameboy, but might=
=20
be supplied by another computer (for example if connected to a PCs=20
parallel port), in that case the external clock may have any speed. Even=20
the old/monochrome gameboy is reported to recognizes external clocks of=20
up to 500KHz. And there is no limitiation into the other direction -=20
even when suppling an external clock speed of "1 bit per month", then=20
the gameboy will still eagerly wait for the next bit(s) to be=20
transferred. It isn't required that the clock pulses are sent at an=20
regular interval either.<br>
<br>
<b>Timeouts<br>
</b>When using external clock then the transfer will not complete until the=
=20
last bit is received. In case that the second gameboy isn't supplying a=20
clock signal, if it gets turned off, or if there is no second gameboy=20
connected at all) then transfer will never complete. For this reason the=20
transfer procedure should use a timeout counter, and abort the=20
communication if no response has been received during the timeout=20
interval.<br>
<br>
<b>Delays and Synchronization<br>
</b>The gameboy that is using internal clock should always execute a small=
=20
delay between each transfer, in order to ensure that the opponent=20
gameboy has enough time to prepare itself for the next transfer, ie. the=20
gameboy with external clock must have set its transfer start bit before=20
the gameboy with internal clock starts the transfer. Alternately, the=20
two gameboys could switch between internal and external clock for each=20
transferred byte to ensure synchronization.<br>
<br>
Transfer is initiated by setting the Transfer Start Flag. This bit is=20
automatically set to 0 at the end of Transfer. Reading this bit can be=20
used to determine if the transfer is still active.<br>
<br>
<b>INT 58 - Serial Interrupt<br>
</b>When the transfer has completed (ie. after sending/receiving 8 bits, if=
=20
any) then an interrupt is requested by setting Bit 3 of the IF Register=20
(FF0F). When that interrupt is enabled, then the Serial Interrupt vector=20
at 0058 is called.<br>
<br>
<b>XXXXXX...<br>
</b><br>
Transmitting and receiving serial data is done simultaneously. The=20
received data is automatically stored in SB.<br>
<br>
The serial I/O port on the Gameboy is a very simple setup and is crude=20
compared to standard RS-232 (IBM-PC) or RS-485 (Macintosh) serial ports.=20
There are no start or stop bits.<br>
<br>
During a transfer, a byte is shifted in at the same time that a byte is=20
shifted out. The rate of the shift is determined by whether the clock=20
source is internal or external.<br>
The most significant bit is shifted in and out first.<br>
<br>
When the internal clock is selected, it drives the clock pin on the game=20
link port and it stays high when not used. During a transfer it will go=20
low eight times to clock in/out each bit.<br>
<br>
The state of the last bit shifted out determines the state of the output=20
line until another transfer takes place.<br>
<br>
If a serial transfer with internal clock is performed and no external=20
GameBoy is present, a value of $FF will be received in the transfer.<br>
<br>
The following code causes $75 to be shifted out the serial port and a=20
byte to be shifted into $FF01:<br>
<br>
<table><tbody><tr><td><pre>    ld   a,$75
    ld  ($FF01),a
    ld   a,$81
    ld  ($FF02),a
</pre></td></tr></tbody></table><br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"timeran=
ddividerregisters"></a><font size=3D"+2">&nbsp;Timer and Divider Registers<=
/font></td></tr></tbody></table><br>
<b>FF04 - DIV - Divider Register (R/W)<br>
</b>This register is incremented at rate of 16384Hz (~16779Hz on SGB). In=
=20
CGB Double Speed Mode it is incremented twice as fast, ie. at 32768Hz.=20
Writing any value to this register resets it to 00h.<br>
<br>
<b>FF05 - TIMA - Timer counter (R/W)<br>
</b>This timer is incremented by a clock frequency specified by the TAC=20
register ($FF07). When the value overflows (gets bigger than FFh) then=20
it will be reset to the value specified in TMA (FF06), and an interrupt=20
will be requested, as described below.<br>
<br>
<b>FF06 - TMA - Timer Modulo (R/W)<br>
</b>When the TIMA overflows, this data will be loaded.<br>
<br>
<b>FF07 - TAC - Timer Control (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 2    - Timer Stop  (0=3DStop, 1=3DStar=
t)
  Bits 1-0 - Input Clock Select
             00:   4096 Hz    (~4194 Hz SGB)
             01: 262144 Hz  (~268400 Hz SGB)
             10:  65536 Hz   (~67110 Hz SGB)
             11:  16384 Hz   (~16780 Hz SGB)
</pre></td></tr></tbody></table><br>
<b>INT 50 - Timer Interrupt<br>
</b>Each time when the timer overflows (ie. when TIMA gets bigger than FFh)=
,=20
then an interrupt is requested by setting Bit 2 in the IF Register=20
(FF0F). When that interrupt is enabled, then the CPU will execute it by=20
calling the timer interrupt vector at 0050h.<br>
<br>
<b>Note<br>
</b>The above described Timer is the built-in timer in the gameboy. It has=
=20
nothing to do with the MBC3s battery buffered Real Time Clock - that's a=20
completely different thing, described in the chapter about Memory=20
Banking Controllers.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"interru=
pts"></a><font size=3D"+2">&nbsp;Interrupts</font></td></tr></tbody></table=
><br>
<b>IME - Interrupt Master Enable Flag (Write Only)<br>
</b><table><tbody><tr><td><pre>  0 - Disable all Interrupts
  1 - Enable all Interrupts that are enabled in IE Register (FFFF)
</pre></td></tr></tbody></table>The IME flag is used to disable all interru=
pts, overriding any enabled=20
bits in the IE Register. It isn't possible to access the IME flag by=20
using a I/O address, instead IME is accessed directly from the CPU, by=20
the following opcodes/operations:<br>
<table><tbody><tr><td><pre>  EI     ;Enable Interrupts  (ie. IME=3D1)
  DI     ;Disable Interrupts (ie. IME=3D0)
  RETI   ;Enable Ints &amp; Return (same as the opcode combination EI, RET)
  &lt;INT&gt;  ;Disable Ints &amp; Call to Interrupt Vector
</pre></td></tr></tbody></table>Whereas &lt;INT&gt; means the operation whi=
ch is automatically executed by the=20
CPU when it executes an interrupt.<br>
<br>
<b>FFFF - IE - Interrupt Enable (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 0: V-Blank  Interrupt Enable  (INT 40h=
)  (1=3DEnable)
  Bit 1: LCD STAT Interrupt Enable  (INT 48h)  (1=3DEnable)
  Bit 2: Timer    Interrupt Enable  (INT 50h)  (1=3DEnable)
  Bit 3: Serial   Interrupt Enable  (INT 58h)  (1=3DEnable)
  Bit 4: Joypad   Interrupt Enable  (INT 60h)  (1=3DEnable)
</pre></td></tr></tbody></table><br>
<b>FF0F - IF - Interrupt Flag (R/W)<br>
</b><table><tbody><tr><td><pre>  Bit 0: V-Blank  Interrupt Request (INT 40h=
)  (1=3DRequest)
  Bit 1: LCD STAT Interrupt Request (INT 48h)  (1=3DRequest)
  Bit 2: Timer    Interrupt Request (INT 50h)  (1=3DRequest)
  Bit 3: Serial   Interrupt Request (INT 58h)  (1=3DRequest)
  Bit 4: Joypad   Interrupt Request (INT 60h)  (1=3DRequest)
</pre></td></tr></tbody></table>When an interrupt signal changes from low t=
o high, then the=20
corresponding bit in the IF register becomes set. For example, Bit 0=20
becomes set when the LCD controller enters into the V-Blank period.<br>
<br>
<b>Interrupt Requests<br>
</b>Any set bits in the IF register are only &lt;requesting&gt; an interrup=
t to be=20
executed. The actual &lt;execution&gt; happens only if both the IME flag, a=
nd=20
the corresponding bit in the IE register are set, otherwise the=20
interrupt 'waits' until both IME and IE allow its execution.<br>
<br>
<b>Interrupt Execution<br>
</b>When an interrupt gets executed, the corresponding bit in the IF=20
register becomes automatically reset by the CPU, and the IME flag=20
becomes cleared (disabeling any further interrupts until the program=20
re-enables the interrupts, typically by using the RETI instruction), and=20
the corresponding Interrupt Vector (that are the addresses in range=20
0040h-0060h, as shown in IE and IF register decriptions above) becomes=20
called.<br>
<br>
<b>Manually Requesting/Discarding Interrupts<br>
</b>As the CPU automatically sets and cleares the bits in the IF register i=
t=20
is usually not required to write to the IF register. However, the user=20
may still do that in order to manually request (or discard) interrupts.=20
As for real interrupts, a manually requested interrupt isn't executed=20
unless/until IME and IE allow its execution.<br>
<br>
<b>Interrupt Priorities<br>
</b>In the following three situations it might happen that more than 1 bit=
=20
in the IF register are set, requesting more than one interrupt at once:<br>
<table><tbody><tr><td><pre>  1) More than one interrupt signal changed from=
 Low
     to High at the same time.
  2) Several interrupts have been requested during a
     time in which IME/IE didn't allow these interrupts
     to be executed directly.
  3) The user has written a value with several "1" bits
     (for example 1Fh) to the IF register.
</pre></td></tr></tbody></table>Provided that IME and IE allow the executio=
n of more than one of the=20
requested interrupts, then the interrupt with the highest priority=20
becomes executed first. The priorities are ordered as the bits in the IE=20
and IF registers, Bit 0 (V-Blank) having the highest priority, and Bit 4=20
(Joypad) having the lowest priority.<br>
<br>
<b>Nested Interrupts<br>
</b>The CPU automatically disables all other interrupts by setting IME=3D0=
=20
when it executes an interrupt. Usually IME remains zero until the=20
interrupt procedure returns (and sets IME=3D1 by the RETI instruction).=20
However, if you want any other interrupts of lower or higher (or same)=20
priority to be allowed to be executed from inside of the interrupt=20
procedure, then you can place an EI instruction into the interrupt=20
procedure.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"cgbregi=
sters"></a><font size=3D"+2">&nbsp;CGB Registers</font></td></tr></tbody></=
table><br>
<b>Forward<br>
</b>This chapter describes only CGB (Color Gameboy) registers that didn't=
=20
fit into normal categories - most CGB registers are described in the=20
chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA=20
Transfers, and changed meaning of Bit 0 of LCDC Control register). Also,=20
a changed bit is noted in the chapter about the Serial/Link port.<br>
<br>
<b>Unlocking CGB functions<br>
</b>When using any CGB registers (including those in the Video/Link=20
chapters), you must first unlock CGB features by changing byte 0143h in=20
the cartridge header. Typically use a value of 80h for games which=20
support both CGB and monochrome gameboys, and C0h for games which work=20
on CGBs only. Otherwise, the CGB will operate in monochrome "Non CGB"=20
compatibility mode.<br>
<br>
<b>Detecting CGB (and GBA) functions<br>
</b>CGB hardware can be detected by examing the CPU accumulator (A-register=
)=20
directly after startup. A value of 11h indicates CGB (or GBA) hardware,=20
if so, CGB functions can be used (if unlocked, see above).<br>
When A=3D11h, you may also examine Bit 0 of the CPUs B-Register to=20
separate between CGB (bit cleared) and GBA (bit set), by that detection=20
it is possible to use 'repaired' color palette data matching for GBA=20
displays.<br>
<br>
<b>FF4D - KEY1 - CGB Mode Only - Prepare Speed Switch<br>
</b><table><tbody><tr><td><pre>  Bit 7: Current Speed     (0=3DNormal, 1=3D=
Double) (Read Only)
  Bit 0: Prepare Speed Switch (0=3DNo, 1=3DPrepare) (Read/Write)
</pre></td></tr></tbody></table>This register is used to prepare the gamebo=
y to switch between CGB=20
Double Speed Mode and Normal Speed Mode. The actual speed switch is=20
performed by executing a STOP command after Bit 0 has been set. After=20
that Bit 0 will be cleared automatically, and the gameboy will operate=20
at the 'other' speed. The recommended speed switching procedure in=20
pseudo code would be:<br>
<table><tbody><tr><td><pre>  IF KEY1_BIT7 &lt;&gt; DESIRED_SPEED THEN
    IE=3D00H       ;(FFFF)=3D00h
    JOYP=3D30H     ;(FF00)=3D30h
    KEY1=3D01H     ;(FF4D)=3D01h
    STOP         ;STOP
  ENDIF
</pre></td></tr></tbody></table>The CGB is operating in Normal Speed Mode w=
hen it is turned on. Note=20
that using the Double Speed Mode increases the power consumption, it=20
would be recommended to use Single Speed whenever possible. However, the=20
display will flicker (white) for a moment during speed switches, so this=20
cannot be done permanentely.<br>
In Double Speed Mode the following will operate twice as fast as normal:<br=
>
<table><tbody><tr><td><pre>  The CPU (2.10 MHz, 1 Cycle =3D approx. 0.5us)
  Timer and Divider Registers
  Serial Port (Link Cable)
  DMA Transfer to OAM
</pre></td></tr></tbody></table>And the following will keep operating as us=
ual:<br>
<table><tbody><tr><td><pre>  LCD Video Controller
  HDMA Transfer to VRAM
  All Sound Timings and Frequencies
</pre></td></tr></tbody></table><br>
<b>FF56 - RP - CGB Mode Only - Infrared Communications Port<br>
</b>This register allows to input and output data through the CGBs built-in=
=20
Infrared Port. When reading data, bit 6 and 7 must be set (and obviously=20
Bit 0 must be cleared - if you don't want to receive your own gameboys=20
IR signal). After sending or receiving data you should reset the=20
register to 00h to reduce battery power consumption again.<br>
<table><tbody><tr><td><pre>  Bit 0:   Write Data   (0=3DLED Off, 1=3DLED On=
)             (Read/Write)
  Bit 1:   Read Data    (0=3DReceiving IR Signal, 1=3DNormal) (Read Only)
  Bit 6-7: Data Read Enable (0=3DDisable, 3=3DEnable)         (Read/Write)
</pre></td></tr></tbody></table>Note that the receiver will adapt itself to=
 the normal level of IR=20
pollution in the air, so if you would send a LED ON signal for a longer=20
period, then the receiver would treat that as normal (=3DOFF) after a=20
while. For example, a Philips TV Remote Control sends a series of 32 LED=20
ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent=20
880us LED ON signal.<br>
Even though being generally CGB compatible, the GBA does not include an=20
infra-red port.<br>
<br>
<b>FF70 - SVBK - CGB Mode Only - WRAM Bank<br>
</b>In CGB Mode 32 KBytes internal RAM are available. This memory is divide=
d=20
into 8 banks of 4 KBytes each. Bank 0 is always available in memory at=20
C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.<br=
>
<table><tbody><tr><td><pre>  Bit 0-2  Select WRAM Bank (Read/Write)
</pre></td></tr></tbody></table>Writing a value of 01h-07h will select Bank=
 1-7, writing a value of 00h=20
will select Bank 1 either.<br>
<br>
<b>FF6C - Undocumented (FEh) - Bit 0   (Read/Write) - CGB Mode Only<br>
FF72 - Undocumented (00h) - Bit 0-7 (Read/Write)<br>
FF73 - Undocumented (00h) - Bit 0-7 (Read/Write)<br>
FF74 - Undocumented (00h) - Bit 0-7 (Read/Write) - CGB Mode Only<br>
FF75 - Undocumented (8Fh) - Bit 4-6 (Read/Write)<br>
FF76 - Undocumented (00h) - Always 00h (Read Only)<br>
FF77 - Undocumented (00h) - Always 00h (Read Only)<br>
</b>These are undocumented CGB Registers. The numbers in brackets ()=20
indicate the initial values. Purpose of these registers is unknown (if=20
any). Registers FF6C and FF74 are always FFh if the CGB is in Non CGB=20
Mode.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"sgbfunc=
tions"></a><font size=3D"+2">&nbsp;SGB Functions</font></td></tr></tbody></=
table><br>
<b>General Information<br>
</b><a href=3D"http://bgb.bircd.org/pandocs.htm#sgbdescription">SGB Descrip=
tion</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#sgbunlockinganddetectingsgbfunc=
tions">SGB Unlocking and Detecting SGB Functions</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#sgbcommandpackettransfers">SGB =
Command Packet Transfers</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#sgbvramtransfers">SGB VRAM Tran=
sfers</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#sgbcommandsummary">SGB Command =
Summary</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#sgbcolorpalettesoverview">SGB C=
olor Palettes Overview</a><br>
<br>
<b>SGB Commands<br>
</b><a href=3D"http://bgb.bircd.org/pandocs.htm#sgbpalettecommands">SGB Pal=
ette Commands</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#sgbcolorattributecommands">SGB =
Color Attribute Commands</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#sgbsoundfunctions">SGB Sound Fu=
nctions</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#sgbsystemcontrolcommands">SGB S=
ystem Control Commands</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#sgbmultiplayercommand">SGB Mult=
iplayer Command</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#sgbborderandobjcommands">SGB Bo=
rder and OBJ Commands</a><br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"sgbdesc=
ription"></a><font size=3D"+2">&nbsp;SGB Description</font></td></tr></tbod=
y></table><br>
<b>General Description<br>
</b>Basically, the SGB (Super Gameboy) is an adapter cartridge that allows=
=20
to play gameboy games on a SNES (Super Nintendo Entertainment System)=20
gaming console. In detail, you plug the gameboy cartridge into the SGB=20
cartridge, then plug the SGB cartridge into the SNES, and then connect=20
the SNES to your TV Set. In result, games can be played and viewed on=20
the TV Set, and are controlled by using the SNES joypad(s).<br>
<br>
<b>More Technical Description<br>
</b>The SGB cartridge just contains a normal gameboy CPU and normal gameboy=
=20
video controller. Normally the video signal from this controller would=20
be sent to the LCD screen, however, in this special case the SNES read=20
out the video signal and displays it on the TV set by using a special=20
SNES BIOS ROM which is located in the SGB cartridge. Also, normal=20
gameboy sound output is forwared to the SNES and output to the TV Set,=20
vice versa, joypad input is forwared from the SNES controller(s) to the=20
gameboy joypad inputs.<br>
<br>
<b>Normal Monochrome Games<br>
</b>Any gameboy games which have been designed for normal monochrome=20
handheld gameboys will work with the SGB hardware as well. The SGB will=20
apply a four color palette to these games by replacing the normal four=20
grayshades. The 160x144 pixel gamescreen is displayed in the middle of=20
the 256x224 pixel SNES screen (the unused area is filled by a screen=20
border bitmap). The user may access built-in menues, allowing to change=20
color palette data, to select between several pre-defined borders, etc.<br>
<br>
Games that have been designed to support SGB functions may also access=20
the following additional features:<br>
<br>
<b>Colorized Game Screen<br>
</b>There's limited ability to colorize the gamescreen by assigning custom=
=20
color palettes to each 20x18 display characters, however, this works=20
mainly for static display data such like title screens or status bars,=20
the 20x18 color attribute map is non-scrollable, and it is not possible=20
to assign separate colors to moveable foreground sprites (OBJs), so that=20
animated screen regions will be typically restricted to using a single=20
palette of four colors only.<br>
<br>
<b>SNES Foreground Sprites<br>
</b>Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors ca=
n=20
be displayed. When replacing (or just overlaying) the normal gameboy=20
OBJs by SNES OBJs it'd be thus possible to display OBJs with other=20
colors than normal background area. This method doesn't appear to be=20
very popular, even though it appears to be quite easy to implement,=20
however, the bottommost character line of the gamescreen will be masked=20
out because this area is used to transfer OAM data to the SNES.<br>
<br>
<b>The SGB Border<br>
</b>The possibly most popular and most impressive feature is to replace the=
=20
default SGB screen border by a custom bitmap which is stored in the game=20
cartridge.<br>
<br>
<b>Multiple Joypads<br>
</b>Up to four joypads can be conected to the SNES, and SGB software may=20
read-out each of these joypads separately, allowing up to four players=20
to play the same game simultaneously. Unlike for multiplayer handheld=20
games, this requires only one game cartridge and only one SGB/SNES, and=20
no link cables are required, the downside is that all players must share=20
the same display screen.<br>
<br>
<b>Sound Functions<br>
</b>Beside for normal gameboy sound, a number of digital sound effects is=
=20
pre-defined in the SNES BIOS, these effects may be accessed quite=20
easily. Programmers whom are familiar with SNES sounds may also access=20
the SNES sound chip, or use the SNES MIDI engine directly in order to=20
produce other sound effects or music.<br>
<br>
<b>Taking Control of the SNES CPU<br>
</b>Finally, it is possible to write program code or data into SNES memory,=
=20
and to execute such program code by using the SNES CPU.<br>
<br>
<b>SGB System Clock<br>
</b>Because the SGB is synchronized to the SNES CPU, the gameboy system=20
clock is directly chained to the SNES system clock. In result, the=20
gameboy CPU, video controller, timers, and sound frequencies will be all=20
operated approx 2.4% faster as by normal gameboys.<br>
Basically, this should be no problem, and the game will just run a=20
little bit faster. However sensitive musicians may notice that sound=20
frequencies are a bit too high, programs that support SGB functions may=20
avoid this effect by reducing frequencies of gameboy sounds when having=20
detected SGB hardware.<br>
Also, I think that I've heard that SNES models which use a 50Hz display=20
refresh rate (rather than 60Hz) are resulting in respectively slower=20
SGB/gameboy timings ???<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"sgbunlo=
ckinganddetectingsgbfunctions"></a><font size=3D"+2">&nbsp;SGB Unlocking an=
d Detecting SGB Functions</font></td></tr></tbody></table><br>
<b>Cartridge Header<br>
</b>SGB games are required to have a cartridge header with Nintendo and=20
proper checksum just as normal gameboy games. Also, two special entries=20
must be set in order to unlock SGB functions:<br>
<table><tbody><tr><td><pre>  146h - SGB Flag - Must be set to 03h for SGB g=
ames
  14Bh - Old Licensee Code - Must be set 33h for SGB games
</pre></td></tr></tbody></table>When these entries aren't set, the game wil=
l still work just like all=20
'monochrome' gameboy games, but it cannot access any of the special SGB=20
functions.<br>
<br>
<b>Detecting SGB hardware<br>
</b>The recommended detection method is to send a MLT_REQ command which=20
enables two (or four) joypads. A normal handheld gameboy will ignore=20
this command, a SGB will now return incrementing joypad IDs each time=20
when deselecting keyboard lines (see MLT_REQ description for details).<br>
Now read-out joypad state/IDs several times, and if the ID-numbers are=20
changing, then it is a SGB (a normal gameboy would typically always=20
return 0Fh as ID). Finally, when not intending to use more than one=20
joypad, send another MLT_REQ command in order to re-disable the=20
multi-controller mode.<br>
Detection works regardless of whether and how many joypads are=20
physically connected to the SNES. However, detection works only when=20
having unlocked SGB functions in the cartridge header, as described=20
above. <br>
<br>
<b>Separating between SGB and SGB2<br>
</b>It is also possible to separate between SGB and SGB2 models by examinin=
g=20
the inital value of the accumulator (A-register) directly after startup.<br=
>
<table><tbody><tr><td><pre>  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA
</pre></td></tr></tbody></table>Because values 01h and FFh are shared for b=
oth handhelds and SGBs, it is=20
still required to use the above MLT_REQ detection procedure. As far as I=20
know the SGB2 doesn't have any extra features which'd require separate=20
SGB2 detection except for curiosity purposes, for example, the game=20
"Tetris DX" chooses to display an alternate SGB border on SGB2s.<br>
<br>
Reportedly, some SGB models include link ports (just like handheld=20
gameboy) (my own SGB does not have such an port), possibly this feature=20
is available in SGB2-type models only ???<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"sgbcomm=
andpackettransfers"></a><font size=3D"+2">&nbsp;SGB Command Packet Transfer=
s</font></td></tr></tbody></table><br>
Command packets (aka Register Files) are transferred from the gameboy to=20
the SNES by using P14 and P15 output lines of the JOYPAD register=20
(FF00h), these lines are normally used to select the two rows in the=20
gameboy keyboard matrix (which still works).<br>
<br>
<b>Transferring Bits<br>
</b>A command packet transfer must be initiated by setting both P14 and P15=
=20
to LOW, this will reset and start the SNES packet receiving program.=20
Data is then transferred (LSB first), setting P14=3DLOW will indicate a=20
"0" bit, and setting P15=3DLOW will indicate a "1" bit. For example:<br>
<table><tbody><tr><td><pre>       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...
</pre></td></tr></tbody></table>Data and reset pulses must be kept LOW for =
at least 5us. P14 and P15=20
must be kept both HIGH for at least 15us between any pulses.<br>
Obviously, it'd be no good idea to access the JOYPAD register during the=20
transfer, for example, in case that your VBlank interrupt procedure=20
reads-out joypad states each frame, be sure to disable that interrupt=20
during the transfer (or disable only the joypad procedure by using a=20
software flag).<br>
<br>
<b>Transferring Packets<br>
</b>Each packet is invoked by a RESET pulse, then 128 bits of data are=20
transferred (16 bytes, LSB of first byte first), and finally, a "0"-bit=20
must be transferred as stop bit. The structure of normal packets is:<br>
<table><tbody><tr><td><pre>   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)
</pre></td></tr></tbody></table>The above 'Length' indicates the total numb=
er of packets (1-7, including=20
the first packet) which will be sent, ie. if more than 15 parameter=20
bytes are used, then further packet(s) will follow, as such:<br>
<table><tbody><tr><td><pre>   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)
</pre></td></tr></tbody></table>By using all 7 packets, up to 111 data byte=
s (15+16*6) may be sent.<br>
Unused bytes at the end of the last packet must be set to zero.<br>
A 60ms (4 frames) delay should be invoked between each packet transfer.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"sgbvram=
transfers"></a><font size=3D"+2">&nbsp;SGB VRAM Transfers</font></td></tr><=
/tbody></table><br>
<b>Overview<br>
</b>Beside for the packet transfer method, larger data blocks of 4KBytes ca=
n=20
be transferred by using the video signal. These transfers are invoked by=20
first sending one of the commands with the ending _TRN (by using normal=20
packet transfer), the 4K data block is then read-out by the SNES from=20
gameboy display memory during the next frame.<br>
<br>
<b>Transfer Data<br>
</b>Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM=
,<br>
even though the SNES receives the data in from display scanlines, it=20
will automatically re-produce the same ordering of bits and bytes, as=20
being originally stored at 8000h-8FFFh in gameboy memory.<br>
<br>
<b>Preparing the Display<br>
</b>The above method works only when recursing the following things: BG Map=
=20
must display unsigned characters 00h-FFh on the screen; 00h..13h in=20
first line, 14h..27h in next line, etc. The gameboy display must be=20
enabled, the display may not be scrolled, OBJ sprites should not overlap=20
the background tiles, the BGP palette register must be set to E4h.<br>
<br>
<b>Transfer Time<br>
</b>Note that the transfer data should be prepared in VRAM &lt;before&gt; s=
ending=20
the transfer command packet. The actual transfer starts at the beginning=20
of the next frame after the command has been sent, and the transfer ends=20
at the end of the 5th frame after the command has been sent (not=20
counting the frame in which the command has been sent).<br>
<br>
<b>Avoiding Screen Garbage<br>
</b>The display will contain 'garbage' during the transfer, this dirt-effec=
t=20
can be avoided by freezing the screen (in the state which has been=20
displayed before the transfer) by using the MASK_EN command.<br>
Of course, this works only when actually executing the game on a SGB=20
(and not on normal handheld gameboys), it'd be thus required to detect=20
the presence of SGB hardware before blindly sending VRAM data.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"sgbcomm=
andsummary"></a><font size=3D"+2">&nbsp;SGB Command Summary</font></td></tr=
></tbody></table><br>
<b>SGB System Command Table<br>
</b><table><tbody><tr><td><pre>  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  "Block" Area Designation Mode
  05   ATTR_LIN  "Line" Area Designation Mode
  06   ATTR_DIV  "Divide" Area Designation Mode
  07   ATTR_CHR  "1CHR" Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode
</pre></td></tr></tbody></table><br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"sgbcolo=
rpalettesoverview"></a><font size=3D"+2">&nbsp;SGB Color Palettes Overview<=
/font></td></tr></tbody></table><br>
<b>Available SNES Palettes<br>
</b>The SGB/SNES provides 8 palettes of 16 colors each, each color may be=
=20
defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are=20
used to colorize the gamescreen, only the first four colors of each of=20
these palettes are used. Palettes 4-7 are used for the SGB Border, all=20
16 colors of each of these palettes may be used.<br>
<br>
<b>Color 0 Restriction<br>
</b>Color 0 of each of the eight palettes is transparent, causing the=20
backdrop color to be displayed instead. The backdrop color is typically=20
defined by the most recently color being assigned to Color 0 (regardless=20
of the palette number being used for that operation).<br>
Effectively, gamescreen palettes can have only three custom colors each,=20
and SGB border palettes only 15 colors each, additionally, color 0 can=20
be used for for all palettes, which will then all share the same color=20
though.<br>
<br>
<b>Translation of Grayshades into Colors<br>
</b>Because the SGB/SNES reads out the gameboy video controllers display=20
signal, it translates the different grayshades from the signal into SNES=20
colors as such:<br>
<table><tbody><tr><td><pre>  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3
</pre></td></tr></tbody></table>Note that gameboy colors 0-3 are assigned t=
o user-selectable grayshades=20
by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed=20
relationship between gameboy colors 0-3 and SNES colors 0-3.<br>
<br>
<b>Using Gameboy BGP/OBP Registers<br>
</b>A direct translation of color 0-3 into color 0-3 may be produced by=20
setting BGP/OBP registers to a value of 0E4h each. However, in case that=20
your program uses black background for example, then you may internally=20
assign background as "White" at the gameboy side by BGP/OBP registers=20
(which is then interpreted as SNES color 0, which is shared for all SNES=20
palettes). The advantage is that you may define Color 0 as Black at the=20
SNES side, and may assign custom colors for Colors 1-3 of each SNES=20
palette.<br>
<br>
<b>System Color Palette Memory<br>
</b>Beside for the actually visible palettes, up to 512 palettes of 4 color=
s=20
each may be defined in SNES RAM. Basically, this is completely=20
irrelevant because the palettes are just stored in RAM whithout any=20
relationship to the displayed picture, anyways, these pre-defined colors=20
may be transferred to actually visible palettes slightly faster as when=20
transferring palette data by separate command packets.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"sgbpale=
ttecommands"></a><font size=3D"+2">&nbsp;SGB Palette Commands</font></td></=
tr></tbody></table><br>
<b>SGB Command 00h - PAL01<br>
</b>Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1=
,=20
color 1-3 (without separate color 0).<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length (fixed length=3D01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)
</pre></td></tr></tbody></table>The value transferred as color 0 will be ap=
plied for all eight palettes.<br>
<br>
<b>SGB Command 01h - PAL23<br>
</b>Same as above PAL01, but for Palettes 2 and 3 respectively.<br>
<br>
<b>SGB Command 02h - PAL03<br>
</b>Same as above PAL01, but for Palettes 0 and 3 respectively.<br>
<br>
<b>SGB Command 03h - PAL12<br>
</b>Same as above PAL01, but for Palettes 1 and 2 respectively.<br>
<br>
<b>SGB Command 0Ah - PAL_SET<br>
</b>Used to copy pre-defined palette data from SGB system color palette to=
=20
actual SGB palette.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length (fixed length=3D1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=3D1)
          Bit 6   - Cancel Mask           (0=3DNo change, 1=3DYes)
          Bit 7   - Use Attribute File    (0=3DNo, 1=3DApply above ATF Numb=
er)
  A-F   Not used (zero)
</pre></td></tr></tbody></table>Before using this function, System Palette =
data should be initialized by=20
PAL_TRN command, and (when used) Attribute File data should be=20
initialized by ATTR_TRN.<br>
<br>
<b>SGB Command 0Bh - PAL_TRN<br>
</b>Used to initialize SGB system color palettes in SNES RAM.<br>
System color palette memory contains 512 pre-defined palettes, these=20
palettes do not directly affect the display, however, the PAL_SET=20
command may be later used to transfer four of these 'logical' palettes=20
to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function=20
will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ=20
palettes (16 colors).<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length (fixed length=3D1)
  1-F   Not used (zero)
</pre></td></tr></tbody></table>The palette data is sent by VRAM-Transfer (=
4 KBytes).<br>
<table><tbody><tr><td><pre>  000-FFF  Data for System Color Palette 0-511
</pre></td></tr></tbody></table>Each Palette consists of four 16bit-color d=
efinitions (8 bytes).<br>
Note: The data is stored at 3000h-3FFFh in SNES memory.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"sgbcolo=
rattributecommands"></a><font size=3D"+2">&nbsp;SGB Color Attribute Command=
s</font></td></tr></tbody></table><br>
<b>SGB Command 04h - ATTR_BLK<br>
</b>Used to specify color attributes for the inside or outside of one or=20
more rectangular screen regions.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length (length=3D1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=3DYes)
            Bit 1 - Change Colors of surrounding character line (1=3DYes)
            Bit 2 - Change Colors outside of surrounded area    (1=3DYes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)
</pre></td></tr></tbody></table>When sending three or more data sets, data =
is continued in further=20
packet(s). Unused bytes at the end of the last packet should be set to=20
zero. The format of the separate Data Sets is described below.<br>
<br>
<b>SGB Command 05h - ATTR_LIN<br>
</b>Used to specify color attributes of one or more horizontal or vertical=
=20
character lines.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length (length=3D1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=3DVertical line, 1=3DHorizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.
</pre></td></tr></tbody></table>When sending 15 or more data sets, data is =
continued in further=20
packet(s). Unused bytes at the end of the last packet should be set to=20
zero. The format of the separate Data Sets (one byte each) is described=20
below.<br>
The length of each line reaches from one end of the screen to the other=20
end. In case that some lines overlap each other, then lines from=20
lastmost data sets will overwrite lines from previous data sets.<br>
<br>
<b>SGB Command 06h - ATTR_DIV<br>
</b>Used to split the screen into two halfes, and to assign separate color=
=20
attributes to each half, and to the division line between them.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length   (fixed length=3D1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=3Dsplit left/right, 1=3Dsplit above/bel=
ow)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)
</pre></td></tr></tbody></table><br>
<b>SGB Command 07h - ATTR_CHR<br>
</b>Used to specify color attributes for separate characters.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length (length=3D1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=3DLeft to Right, 1=3DTop to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.
</pre></td></tr></tbody></table>When sending 41 or more data sets, data is =
continued in further=20
packet(s). Unused bytes at the end of the last packet should be set to=20
zero. Each data set consists of two bits, indicating the palette number=20
for one character.<br>
Depending on the writing style, data sets are written from left to=20
right, or from top to bottom. In either case the function wraps to the=20
next row/column when reaching the end of the screen.<br>
<br>
<b>SGB Command 15h - ATTR_TRN<br>
</b>Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consist=
s=20
of 20x18 color attributes for the gameboy screen. This function does not=20
directly affect display attributes. Instead, one of the defined ATFs may=20
be copied to actual display memory at a later time by using ATTR_SET or=20
PAL_SET functions.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length (fixed length=3D1)
  1-F   Not used (zero)
</pre></td></tr></tbody></table>The ATF data is sent by VRAM-Transfer (4 KB=
ytes).<br>
<table><tbody><tr><td><pre>  000-FD1  Data for ATF0 through ATF44 (4050 byt=
es)
  FD2-FFF  Not used
</pre></td></tr></tbody></table>Each ATF consists of 90 bytes, that are 5 b=
ytes (20x2bits) for each of=20
the 18 character lines of the gameboy window. The two most significant=20
bits of the first byte define the color attribute (0-3) for the first=20
character of the first line, the next two bits the next character, and=20
so on.<br>
<br>
<b>SGB Command 16h - ATTR_SET<br>
</b>Used to transfer attributes from Attribute File (ATF) to gameboy window=
.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length (fixed length=3D1)
  1     Attribute File Number (00-2Ch), Bit 6=3DCancel Mask
  2-F   Not used (zero)
</pre></td></tr></tbody></table>When above Bit 6 is set, the gameboy screen=
 becomes re-enabled after the=20
transfer (in case it has been disabled/frozen by MASK_EN command).<br>
Note: The same functions may be (optionally) also included in PAL_SET=20
commands, as described in the chapter about Color Palette Commands.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"sgbsoun=
dfunctions"></a><font size=3D"+2">&nbsp;SGB Sound Functions</font></td></tr=
></tbody></table><br>
<b>SGB Command 08h - SOUND<br>
</b>Used to start/stop internal sound effect, start/stop sound using=20
internal tone data.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length (fixed length=3D1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=3DLow..High)
          Bit 2-3 - Sound Effect A Volume (0..2=3DHigh..Low, 3=3DMute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=3DLow..High)
          Bit 6-7 - Sound Effect B Volume (0..2=3DHigh..Low, 3=3DNot used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)
</pre></td></tr></tbody></table>See Sound Effect Tables below for a list of=
 available pre-defined effects.<br>
"Notes"<br>
1) Mute is only active when both bits D2 and D3 are 1.<br>
2) When the volume is set for either Sound Effect A or Sound Effect B,=20
mute is turned off.<br>
3) When Mute on/off has been executed, the sound fades out/fades in.<br>
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect=20
A, Sound Effect B, and the Super NES APU. A "mute off" flag does not=20
exist by itself. When mute flag is set, volume and pitch of Sound Effect=20
A (port 1) and Sound Effect B (port 2) must be set.<br>
<br>
<b>SGB Command 09h - SOU_TRN<br>
</b>Used to transfer sound code or data to SNES Audio Processing Unit memor=
y=20
(APU-RAM).<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length (fixed length=3D1)
  1-F   Not used (zero)
</pre></td></tr></tbody></table>The sound code/data is sent by VRAM-Transfe=
r (4 KBytes).<br>
<table><tbody><tr><td><pre>  000      One (or two ???) 16bit expression(s ?=
??) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used
</pre></td></tr></tbody></table>Possible destinations in APU-RAM are:<br>
<table><tbody><tr><td><pre>  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)
</pre></td></tr></tbody></table>This function may be used to take control o=
f the SNES sound chip, and/or=20
to access the SNES MIDI engine. In either case it requires deeper=20
knowledge of SNES sound programming.<br>
<br>
<b>SGB Sound Effect A/B Tables<br>
</b>Below lists the digital sound effects that are pre-defined in the=20
SGB/SNES BIOS, and which can be used with the SGB "SOUND" Command.<br>
Effect A and B may be simultaneously reproduced.<br>
The P-column indicates the recommended Pitch value, the V-column=20
indicates the numbers of Voices used. Sound Effect A uses voices 6,7.=20
Sound Effect B uses voices 0,1,4,5. Effects that use less voices will=20
use only the upper voices (eg. 4,5 for Effect B with only two voices).<br>
<br>
<b>Sound Effect A Flag Table<br>
</b><table><tbody><tr><td><pre>  Code Description             P V     Code =
Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on &amp; off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2
</pre></td></tr></tbody></table>Sound effect A is used for formanto sounds =
(percussion sounds).<br>
<br>
<b>Sound Effect B Flag Table<br>
</b><table><tbody><tr><td><pre>  Code Description             P V     Code =
Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2
</pre></td></tr></tbody></table>Sound effect B is mainly used for looping s=
ounds (sustained sounds).<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"sgbsyst=
emcontrolcommands"></a><font size=3D"+2">&nbsp;SGB System Control Commands<=
/font></td></tr></tbody></table><br>
<b>SGB Command 17h - MASK_EN<br>
</b>Used to mask the gameboy window, among others this can be used to freez=
e=20
the gameboy screen before transferring data through VRAM (the SNES then=20
keeps displaying the gameboy screen, even though VRAM doesn't contain=20
meaningful display information during the transfer).<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length (fixed length=3D1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)
</pre></td></tr></tbody></table>Freezing works only if the SNES has stored =
a picture, ie. if necessary=20
wait one or two frames before freezing (rather than freezing directly=20
after having displayed the picture).<br>
The Cancel Mask function may be also invoked (optionally) by completion=20
of PAL_SET and ATTR_SET commands.<br>
<br>
<b>SGB Command 0Ch - ATRC_EN<br>
</b>Used to enable/disable Attraction mode. It is totally unclear what an=
=20
attraction mode is ???, but it is enabled by default.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length    (fixed length=3D1)
  1     Attraction Disable  (0=3DEnable, 1=3DDisable)
  2-F   Not used (zero)
</pre></td></tr></tbody></table><br>
<b>SGB Command 0Dh - TEST_EN<br>
</b>Used to enable/disable test mode for "SGB-CPU variable clock speed=20
function". This function is disabled by default.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length    (fixed length=3D1)
  1     Test Mode Enable    (0=3DDisable, 1=3DEnable)
  2-F   Not used (zero)
</pre></td></tr></tbody></table>Maybe intended to determine whether SNES op=
erates at 50Hz or 60Hz=20
display refresh rate ??? Possibly result can be read-out from joypad=20
register ???<br>
<br>
<b>SGB Command 0Eh - ICON_EN<br>
</b>Used to enable/disable ICON function. Possibly meant to enable/disable=
=20
SGB/SNES popup menues which might otherwise activated during gameboy=20
game play. By default all functions are enabled (0).<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length    (fixed length=3D1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=3DDisable)
          Bit 1 - Controller Set-up Screen    (0=3DEnable, 1=3DDisable)
          Bit 2 - SGB Register File Transfer (0=3DReceive, 1=3DDisable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)
</pre></td></tr></tbody></table>Above Bit 2 will suppress all further packe=
ts/commands when set, this=20
might be useful when starting a monochrome game from inside of the=20
SGB-menu of a multi-gamepak which contains a collection of different=20
games.<br>
<br>
<b>SGB Command 0Fh - DATA_SND<br>
</b>Used to write one or more bytes directly into SNES Work RAM.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length    (fixed length=3D1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.
</pre></td></tr></tbody></table>Unused bytes at the end of the packet shoul=
d be set to zero, this=20
function is restricted to a single packet, so that not more than 11=20
bytes can be defined at once.<br>
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh=20
0000h-FFFFh.<br>
<br>
<b>SGB Command 10h - DATA_TRN<br>
</b>Used to transfer binary code or data directly into SNES RAM.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length    (fixed length=3D1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)
</pre></td></tr></tbody></table>The data is sent by VRAM-Transfer (4 KBytes=
).<br>
<table><tbody><tr><td><pre>  000-FFF  Data
</pre></td></tr></tbody></table>Free Addresses in SNES memory are Bank 0 18=
00h-1FFFh, Bank 7Fh=20
0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly=
=20
writing to the free 2KBytes at 0:1800h would be a not so good idea ???<br>
<br>
<b>SGB Command 12h - JUMP<br>
</b>Used to set the SNES program counter to a specified address. Optionally=
,=20
it may be used to set a new address for the SNES NMI handler, the NMI=20
handler remains unchanged if all bytes 4-6 are zero.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length    (fixed length=3D1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero
</pre></td></tr></tbody></table>Note: The game "Space Invaders 94" uses thi=
s function when selecting=20
"Arcade mode" to execute SNES program code which has been previously=20
transferred from the SGB to the SNES. The type of the CPU which is used=20
in the SNES is unknown ???<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"sgbmult=
iplayercommand"></a><font size=3D"+2">&nbsp;SGB Multiplayer Command</font><=
/td></tr></tbody></table><br>
<b>SGB Command 11h - MLT_REQ<br>
</b>Used to request multiplayer mode (ie. input from more than one joypad).=
<br>
Because this function provides feedback from the SGB/SNES to the gameboy=20
program, it is also used to detect SGB hardware.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length    (fixed length=3D1)
  1     Multiplayer Control (0-3) (Bit0=3DEnable, Bit1=3DTwo/Four Players)
          0 =3D One player
          1 =3D Two players
          3 =3D Four players
  2-F   Not used (zero)
</pre></td></tr></tbody></table>In one player mode, the second joypad (if a=
ny) is used for the SGB=20
system program. In two player mode, both joypads are used for the game.=20
Because SNES have only two joypad sockets, four player mode requires an=20
external "Multiplayer 5" adapter.<br>
<br>
<b>Reading Multiple Controllers (Joypads)<br>
</b>When having enabled multiple controllers by MLT_REQ, data for each=20
joypad can be read out through JOYPAD register (FF00) as follows: First=20
set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you=20
can now read the lower 4bits of FF00 which indicate the joypad ID for=20
the following joypad input:<br>
<table><tbody><tr><td><pre>  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4
</pre></td></tr></tbody></table>Next, set P14 and P15 low (one after each o=
ther) to select Buttons and=20
Cursor lines, and read-out joypad state as normally. When completed, set=20
P14 and P15 back HIGH, this automatically increments the joypad number=20
(or restarts counting once reached the lastmost joypad). Repeat the=20
procedure until you have read-out states for all two (or four) joypads.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"sgbbord=
erandobjcommands"></a><font size=3D"+2">&nbsp;SGB Border and OBJ Commands</=
font></td></tr></tbody></table><br>
<b>SGB Command 13h - CHR_TRN<br>
</b>Used to transfer tile data (characters) to SNES Tile memory in VRAM. Th=
is=20
normally used to define BG tiles for the SGB Border (see PCT_TRN), but=20
might be also used to define moveable SNES foreground sprites (see=20
OBJ_TRN).<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length    (fixed length=3D1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=3DTiles 00h-7Fh, 1=3DTiles 80h-FFh)
          Bit 1   - Tile Type      (0=3DBG Tiles, 1=3DOBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)
</pre></td></tr></tbody></table>The tile data is sent by VRAM-Transfer (4 K=
Bytes).<br>
<table><tbody><tr><td><pre>  000-FFF  Bitmap data for 128 Tiles
</pre></td></tr></tbody></table>Each tile occupies 16bytes (8x8 pixels, 16 =
colors each).<br>
When intending to transfer more than 128 tiles, call this function twice=20
(once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ=20
Bit seems to have no effect and writes to the same VRAM addresses for=20
both BG and OBJ ???<br>
<br>
<b>SGB Command 14h - PCT_TRN<br>
</b>Used to transfer tile map data and palette data to SNES BG Map memory i=
n=20
VRAM to be used for the SGB border. The actual tiles must be separately=20
transferred by using the CHR_TRN function.<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length    (fixed length=3D1)
  1-F   Not used (zero)
</pre></td></tr></tbody></table>The map data is sent by VRAM-Transfer (4 KB=
ytes).<br>
<table><tbody><tr><td><pre>  000-7FF  BG Map 32x32 Entries of 16bit each (2=
048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care
</pre></td></tr></tbody></table>Each BG Map Entry consists of a 16bit value=
 as such:<br>
<table><tbody><tr><td><pre>  Bit 0-9   - Character Number (use only 00h-FFh=
, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=3DNormal, 1=3DMirror horizontally)
  Bit 15    - Y-Flip           (0=3DNormal, 1=3DMirror vertically)
</pre></td></tr></tbody></table>Even though 32x32 map entries are transferr=
ed, only upper 32x28 are=20
actually used (256x224 pixels, SNES screen size). The 20x18 entries in=20
the center of the 32x28 area should be set to 0000h as transparent space=20
for the gameboy window to be displayed inside. Reportedly,=20
non-transparent border data will cover the gameboy window.<br>
<br>
<b>SGB Command 18h - OBJ_TRN<br>
</b>Used to transfer OBJ attributes to SNES OAM memory. Unlike all other=20
functions with the ending _TRN, this function does not use the usual=20
one-shot 4KBytes VRAM transfer method.<br>
Instead, when enabled (below execute bit set), data is permanently (each=20
frame) read out from the lower character line of the gameboy screen. To=20
suppress garbage on the display, the lower line is masked, and only the=20
upper 20x17 characters of the gameboy window are used - the masking=20
method is unknwon - frozen, black, or recommended to be covered by the=20
SGB border, or else ??? Also, when the function is enabled, "system=20
attract mode is not performed" - whatever that means ???<br>
<table><tbody><tr><td><pre>  Byte  Content
  0     Command*8+Length (fixed length=3D1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=3DCancel, 1=3DEnable)
          Bit 1   - Change OBJ Color     (0=3DNo, 1=3DUse definitions below=
)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)
</pre></td></tr></tbody></table>The recommended method is to "display" game=
boy BG tiles F9h..FFh from=20
left to right as first 7 characters of the bottom-most character line of=20
the gameboy screen. As for normal 4KByte VRAM transfers, this area=20
should not be scrolled, should not be overlapped by gameboy OBJs, and=20
the gameboy BGP palette register should be set up properly. By following=20
that method, SNES OAM data can be defined in the 70h bytes of the=20
gameboy BG tile memory at following addresses:<br>
<table><tbody><tr><td><pre>  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes eac=
h (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)
</pre></td></tr></tbody></table>The format of SNES OAM Entries is:<br>
<table><tbody><tr><td><pre>  Byte 0  OBJ X-Position (0-511, MSB is separate=
ly stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=3DNormal, 1=3DMirror horizontally)
    Bit 15     Y-Flip          (0=3DNormal, 1=3DMirror vertically)
</pre></td></tr></tbody></table>The format of SNES OAM MSB Entries is:<br>
<table><tbody><tr><td><pre>  Actually, the format is unknown ??? However, 2=
 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).
</pre></td></tr></tbody></table><br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"cpuregi=
stersandflags"></a><font size=3D"+2">&nbsp;CPU Registers and Flags</font></=
td></tr></tbody></table><br>
<b>Registers<br>
</b><table><tbody><tr><td><pre>  16bit Hi   Lo   Name/Function
  AF    A    -    Accumulator &amp; Flags
  BC    B    C    BC
  DE    D    E    DE
  HL    H    L    HL
  SP    -    -    Stack Pointer
  PC    -    -    Program Counter/Pointer
</pre></td></tr></tbody></table>As shown above, most registers can be acces=
sed either as one 16bit=20
register, or as two separate 8bit registers.<br>
<br>
<b>The Flag Register (lower 8bit of AF register)<br>
</b><table><tbody><tr><td><pre>  Bit  Name  Set Clr  Expl.
  7    zf    Z   NZ   Zero Flag
  6    n     -   -    Add/Sub-Flag (BCD)
  5    h     -   -    Half Carry Flag (BCD)
  4    cy    C   NC   Carry Flag
  3-0  -     -   -    Not used (always zero)
</pre></td></tr></tbody></table>Conatins the result from the recent instruc=
tion which has affected=20
flags.<br>
<br>
<b>The Zero Flag (Z)<br>
</b>This bit becomes set (1) if the result of an operation has been zero=20
(0). Used for conditional jumps.<br>
<br>
<b>The Carry Flag (C, or Cy)<br>
</b>Becomes set when the result of an addition became bigger than FFh (8bit=
)=20
or FFFFh (16bit). Or when the result of a subtraction or comparision=20
became less than zero (much as for Z80 and 80x86 CPUs, but unlike as for=20
65XX and ARM CPUs). Also the flag becomes set when a rotate/shift=20
operation has shifted-out a "1"-bit.<br>
Used for conditional jumps, and for instructions such like ADC, SBC, RL,=20
RLA, etc.<br>
<br>
<b>The BCD Flags (N, H)<br>
</b>These flags are (rarely) used for the DAA instruction only, N Indicates=
=20
whether the previous instruction has been an addition or subtraction,=20
and H indicates carry for lower 4bits of the result, also for DAA, the C=20
flag must indicate carry for upper 8bits.<br>
After adding/subtracting two BCD numbers, DAA is intended to convert the=20
result into BCD format; BCD numbers are ranged from 00h to 99h rather=20
than 00h to FFh.<br>
Because C and H flags must contain carry-outs for each digit, DAA cannot=20
be used for 16bit operations (which have 4 digits), or for INC/DEC=20
operations (which do not affect C-flag).<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"cpuinst=
ructionset"></a><font size=3D"+2">&nbsp;CPU Instruction Set</font></td></tr=
></tbody></table><br>
Tables below specify the mnemonic, opcode bytes, clock cycles, affected=20
flags (ordered as znhc), and explanatation.<br>
The timings assume a CPU clock frequency of 4.194304 MHz (or 8.4<br>
MHz for CGB in double speed mode), as all gameboy timings are divideable<br=
>
by 4, many people specify timings and clock frequency divided by 4.<br>
<br>
<b>GMB 8bit-Loadcommands<br>
</b><table><tbody><tr><td><pre>  ld   r,r         xx         4 ---- r=3Dr
  ld   r,n         xx nn      8 ---- r=3Dn
  ld   r,(HL)      xx         8 ---- r=3D(HL)
  ld   (HL),r      7x         8 ---- (HL)=3Dr
  ld   (HL),n      36 nn     12 ----
  ld   A,(BC)      0A         8 ----
  ld   A,(DE)      1A         8 ----
  ld   A,(nn)      FA        16 ----
  ld   (BC),A      02         8 ----
  ld   (DE),A      12         8 ----
  ld   (nn),A      EA        16 ----
  ld   A,(FF00+n)  F0 nn     12 ---- read from io-port n (memory FF00+n)
  ld   (FF00+n),A  E0 nn     12 ---- write to io-port n (memory FF00+n)
  ld   A,(FF00+C)  F2         8 ---- read from io-port C (memory FF00+C)
  ld   (FF00+C),A  E2         8 ---- write to io-port C (memory FF00+C)
  ldi  (HL),A      22         8 ---- (HL)=3DA, HL=3DHL+1
  ldi  A,(HL)      2A         8 ---- A=3D(HL), HL=3DHL+1
  ldd  (HL),A      32         8 ---- (HL)=3DA, HL=3DHL-1
  ldd  A,(HL)      3A         8 ---- A=3D(HL), HL=3DHL-1
</pre></td></tr></tbody></table><br>
<b>GMB 16bit-Loadcommands<br>
</b><table><tbody><tr><td><pre>  ld   rr,nn       x1 nn nn  12 ---- rr=3Dnn=
 (rr may be BC,DE,HL or SP)
  ld   SP,HL       F9         8 ---- SP=3DHL
  push rr          x5        16 ---- SP=3DSP-2  (SP)=3Drr   (rr may be BC,D=
E,HL,AF)
  pop  rr          x1        12 (AF) rr=3D(SP)  SP=3DSP+2   (rr may be BC,D=
E,HL,AF)
</pre></td></tr></tbody></table><br>
<b>GMB 8bit-Arithmetic/logical Commands<br>
</b><table><tbody><tr><td><pre>  add  A,r         8x         4 z0hc A=3DA+r
  add  A,n         C6 nn      8 z0hc A=3DA+n
  add  A,(HL)      86         8 z0hc A=3DA+(HL)
  adc  A,r         8x         4 z0hc A=3DA+r+cy
  adc  A,n         CE nn      8 z0hc A=3DA+n+cy
  adc  A,(HL)      8E         8 z0hc A=3DA+(HL)+cy
  sub  r           9x         4 z1hc A=3DA-r
  sub  n           D6 nn      8 z1hc A=3DA-n
  sub  (HL)        96         8 z1hc A=3DA-(HL)
  sbc  A,r         9x         4 z1hc A=3DA-r-cy
  sbc  A,n         DE nn      8 z1hc A=3DA-n-cy
  sbc  A,(HL)      9E         8 z1hc A=3DA-(HL)-cy
  and  r           Ax         4 z010 A=3DA &amp; r
  and  n           E6 nn      8 z010 A=3DA &amp; n
  and  (HL)        A6         8 z010 A=3DA &amp; (HL)
  xor  r           Ax         4 z000
  xor  n           EE nn      8 z000
  xor  (HL)        AE         8 z000
  or   r           Bx         4 z000 A=3DA | r
  or   n           F6 nn      8 z000 A=3DA | n
  or   (HL)        B6         8 z000 A=3DA | (HL)
  cp   r           Bx         4 z1hc compare A-r
  cp   n           FE nn      8 z1hc compare A-n
  cp   (HL)        BE         8 z1hc compare A-(HL)
  inc  r           xx         4 z0h- r=3Dr+1
  inc  (HL)        34        12 z0h- (HL)=3D(HL)+1
  dec  r           xx         4 z1h- r=3Dr-1
  dec  (HL)        35        12 z1h- (HL)=3D(HL)-1
  daa              27         4 z-0x decimal adjust akku
  cpl              2F         4 -11- A =3D A xor FF
</pre></td></tr></tbody></table><br>
<b>GMB 16bit-Arithmetic/logical Commands<br>
</b><table><tbody><tr><td><pre>  add  HL,rr     x9           8 -0hc HL =3D =
HL+rr     ;rr may be BC,DE,HL,SP
  inc  rr        x3           8 ---- rr =3D rr+1      ;rr may be BC,DE,HL,S=
P
  dec  rr        xB           8 ---- rr =3D rr-1      ;rr may be BC,DE,HL,S=
P
  add  SP,dd     E8          16 00hc SP =3D SP +/- dd ;dd is 8bit signed nu=
mber
  ld   HL,SP+dd  F8          12 00hc HL =3D SP +/- dd ;dd is 8bit signed nu=
mber
</pre></td></tr></tbody></table><br>
<b>GMB Rotate- und Shift-Commands<br>
</b><table><tbody><tr><td><pre>  rlca           07           4 000c rotate =
akku left
  rla            17           4 000c rotate akku left through carry
  rrca           0F           4 000c rotate akku right
  rra            1F           4 000c rotate akku right through carry
  rlc  r         CB 0x        8 z00c rotate left
  rlc  (HL)      CB 06       16 z00c rotate left
  rl   r         CB 1x        8 z00c rotate left through carry
  rl   (HL)      CB 16       16 z00c rotate left through carry
  rrc  r         CB 0x        8 z00c rotate right
  rrc  (HL)      CB 0E       16 z00c rotate right
  rr   r         CB 1x        8 z00c rotate right through carry
  rr   (HL)      CB 1E       16 z00c rotate right through carry
  sla  r         CB 2x        8 z00c shift left arithmetic (b0=3D0)
  sla  (HL)      CB 26       16 z00c shift left arithmetic (b0=3D0)
  swap r         CB 3x        8 z000 exchange low/hi-nibble
  swap (HL)      CB 36       16 z000 exchange low/hi-nibble
  sra  r         CB 2x        8 z00c shift right arithmetic (b7=3Db7)
  sra  (HL)      CB 2E       16 z00c shift right arithmetic (b7=3Db7)
  srl  r         CB 3x        8 z00c shift right logical (b7=3D0)
  srl  (HL)      CB 3E       16 z00c shift right logical (b7=3D0)
</pre></td></tr></tbody></table><br>
<b>GMB Singlebit Operation Commands<br>
</b><table><tbody><tr><td><pre>  bit  n,r       CB xx        8 z01- test bi=
t n
  bit  n,(HL)    CB xx       12 z01- test bit n
  set  n,r       CB xx        8 ---- set bit n
  set  n,(HL)    CB xx       16 ---- set bit n
  res  n,r       CB xx        8 ---- reset bit n
  res  n,(HL)    CB xx       16 ---- reset bit n
</pre></td></tr></tbody></table><br>
<b>GMB CPU-Controlcommands<br>
</b><table><tbody><tr><td><pre>  ccf            3F           4 -00c cy=3Dcy=
 xor 1
  scf            37           4 -001 cy=3D1
  nop            00           4 ---- no operation
  halt           76         N*4 ---- halt until interrupt occurs (low power=
)
  stop           10 00        ? ---- low power standby mode (VERY low power=
)
  di             F3           4 ---- disable interrupts, IME=3D0
  ei             FB           4 ---- enable interrupts, IME=3D1
</pre></td></tr></tbody></table><br>
<b>GMB Jumpcommands<br>
</b><table><tbody><tr><td><pre>  jp   nn        C3 nn nn    16 ---- jump to=
 nn, PC=3Dnn
  jp   HL        E9           4 ---- jump to HL, PC=3DHL
  jp   f,nn      xx nn nn 16;12 ---- conditional jump if nz,z,nc,c
  jr   PC+dd     18 dd       12 ---- relative jump to nn (PC=3DPC+/-7bit)
  jr   f,PC+dd   xx dd     12;8 ---- conditional relative jump if nz,z,nc,c
  call nn        CD nn nn    24 ---- call to nn, SP=3DSP-2, (SP)=3DPC, PC=
=3Dnn
  call f,nn      xx nn nn 24;12 ---- conditional call if nz,z,nc,c
  ret            C9          16 ---- return, PC=3D(SP), SP=3DSP+2
  ret  f         xx        20;8 ---- conditional return if nz,z,nc,c
  reti           D9          16 ---- return and enable interrupts (IME=3D1)
  rst  n         xx          16 ---- call to 00,08,10,18,20,28,30,38
</pre></td></tr></tbody></table><br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"cpucomp=
arisionwithz80"></a><font size=3D"+2">&nbsp;CPU Comparision with Z80</font>=
</td></tr></tbody></table><br>
<b>Comparision with 8080<br>
</b>Basically, the gameboy CPU works more like an older 8080 CPU rather tha=
n=20
like a more powerful Z80 CPU. It is, however, supporting CB-prefixed=20
instructions. Also, all known gameboy assemblers using the more obvious=20
Z80-style syntax, rather than the chaotic 8080-style syntax.<br>
<br>
<b>Comparision with Z80<br>
</b>Any DD-, ED-, and FD-prefixed instructions are missing, that means no=
=20
IX-, IY-registers, no block commands, and some other missing commands.<br>
All exchange instructions have been removed (including total absence of=20
second register set), 16bit memory accesses are mostly missing, and=20
16bit arithmetic functions are heavily cut-down.<br>
The gameboy has no IN/OUT instructions, instead I/O ports are accessed=20
directly by normal LD instructions, or by special LD (FF00+n) opcodes.<br>
The sign and parity/overflow flags have been removed.<br>
The gameboy operates approximately as fast as a 4MHz Z80 (8MHz in CGB=20
double speed mode), execution time of all instructions has been rounded=20
up to a multiple of 4 cycles though.<br>
<br>
<b>Moved, Removed, and Added Opcodes<br>
</b><table><tbody><tr><td><pre>  Opcode  Z80             GMB
  ---------------------------------------
  08      EX   AF,AF      LD   (nn),SP
  10      DJNZ PC+dd      STOP
  22      LD   (nn),HL    LDI  (HL),A
  2A      LD   HL,(nn)    LDI  A,(HL)
  32      LD   (nn),A     LDD  (HL),A
  3A      LD   A,(nn)     LDD  A,(HL)
  D3      OUT  (n),A      -
  D9      EXX             RETI
  DB      IN   A,(n)      -
  DD      &lt;IX&gt;            -
  E0      RET  PO         LD   (FF00+n),A
  E2      JP   PO,nn      LD   (FF00+C),A
  E3      EX   (SP),HL    -
  E4      CALL P0,nn      -
  E8      RET  PE         ADD  SP,dd
  EA      JP   PE,nn      LD   (nn),A
  EB      EX   DE,HL      -
  EC      CALL PE,nn      -
  ED      &lt;pref&gt;          -
  F0      RET  P          LD   A,(FF00+n)
  F2      JP   P,nn       LD   A,(FF00+C)
  F4      CALL P,nn       -
  F8      RET  M          LD   HL,SP+dd
  FA      JP   M,nn       LD   A,(nn)
  FC      CALL M,nn       -
  FD      &lt;IY&gt;            -
  CB3X    SLL  r/(HL)     SWAP r/(HL)
</pre></td></tr></tbody></table>Note: The unused (-) opcodes will lock-up t=
he gameboy CPU when used.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"thecart=
ridgeheader"></a><font size=3D"+2">&nbsp;The Cartridge Header</font></td></=
tr></tbody></table><br>
An internal information area is located at 0100-014F in<br>
each cartridge. It contains the following values:<br>
<br>
<b>0100-0103 - Entry Point<br>
</b>After displaying the Nintendo Logo, the built-in boot procedure jumps t=
o=20
this address (100h), which should then jump to the actual main program=20
in the cartridge. Usually this 4 byte area contains a NOP instruction,=20
followed by a JP 0150h instruction. But not always.<br>
<br>
<b>0104-0133 - Nintendo Logo<br>
</b>These bytes define the bitmap of the Nintendo logo that is displayed=20
when the gameboy gets turned on. The hexdump of this bitmap is:<br>
<table><tbody><tr><td><pre>  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0=
D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E
</pre></td></tr></tbody></table>The gameboys boot procedure verifies the co=
ntent of this bitmap (after=20
it has displayed it), and LOCKS ITSELF UP if these bytes are incorrect.=20
A CGB verifies only the first 18h bytes of the bitmap, but others (for=20
example a pocket gameboy) verify all 30h bytes.<br>
<br>
<b>0134-0143 - Title<br>
</b>Title of the game in UPPER CASE ASCII. If it is less than 16 characters=
=20
then the remaining bytes are filled with 00's. When inventing the CGB,=20
Nintendo has reduced the length of this area to 15 characters, and some=20
months later they had the fantastic idea to reduce it to 11 characters=20
only. The new meaning of the ex-title bytes is described below.<br>
<br>
<b>013F-0142 - Manufacturer Code<br>
</b>In older cartridges this area has been part of the Title (see above), i=
n=20
newer cartridges this area contains an 4 character uppercase=20
manufacturer code. Purpose and Deeper Meaning unknown.<br>
<br>
<b>0143 - CGB Flag<br>
</b>In older cartridges this byte has been part of the Title (see above). I=
n=20
CGB cartridges the upper bit is used to enable CGB functions. This is=20
required, otherwise the CGB switches itself into Non-CGB-Mode. Typical=20
values are:<br>
<table><tbody><tr><td><pre>  80h - Game supports CGB functions, but works o=
n old gameboys also.
  C0h - Game works on CGB only (physically the same as 80h).
</pre></td></tr></tbody></table>Values with Bit 7 set, and either Bit 2 or =
3 set, will switch the=20
gameboy into a special non-CGB-mode with uninitialized palettes. Purpose=20
unknown, eventually this has been supposed to be used to colorize=20
monochrome games that include fixed palette data at a special location=20
in ROM.<br>
<br>
<b>0144-0145 - New Licensee Code<br>
</b>Specifies a two character ASCII licensee code, indicating the company o=
r=20
publisher of the game. These two bytes are used in newer games only=20
(games that have been released after the SGB has been invented). Older=20
games are using the header entry at 014B instead.<br>
<br>
<b>0146 - SGB Flag<br>
</b>Specifies whether the game supports SGB functions, common values are:<b=
r>
<table><tbody><tr><td><pre>  00h =3D No SGB functions (Normal Gameboy or CG=
B only game)
  03h =3D Game supports SGB functions
</pre></td></tr></tbody></table>The SGB disables its SGB functions if this =
byte is set to another value=20
than 03h.<br>
<br>
<b>0147 - Cartridge Type<br>
</b>Specifies which Memory Bank Controller (if any) is used in the=20
cartridge, and if further external hardware exists in the cartridge.<br>
<table><tbody><tr><td><pre>  00h  ROM ONLY                 13h  MBC3+RAM+BA=
TTERY
  01h  MBC1                     15h  MBC4
  02h  MBC1+RAM                 16h  MBC4+RAM
  03h  MBC1+RAM+BATTERY         17h  MBC4+RAM+BATTERY
  05h  MBC2                     19h  MBC5
  06h  MBC2+BATTERY             1Ah  MBC5+RAM
  08h  ROM+RAM                  1Bh  MBC5+RAM+BATTERY
  09h  ROM+RAM+BATTERY          1Ch  MBC5+RUMBLE
  0Bh  MMM01                    1Dh  MBC5+RUMBLE+RAM
  0Ch  MMM01+RAM                1Eh  MBC5+RUMBLE+RAM+BATTERY
  0Dh  MMM01+RAM+BATTERY        FCh  POCKET CAMERA
  0Fh  MBC3+TIMER+BATTERY       FDh  BANDAI TAMA5
  10h  MBC3+TIMER+RAM+BATTERY   FEh  HuC3
  11h  MBC3                     FFh  HuC1+RAM+BATTERY
  12h  MBC3+RAM
</pre></td></tr></tbody></table><br>
<b>0148 - ROM Size<br>
</b>Specifies the ROM Size of the cartridge. Typically calculated as "32KB=
=20
shl N".<br>
<table><tbody><tr><td><pre>  00h -  32KByte (no ROM banking)
  01h -  64KByte (4 banks)
  02h - 128KByte (8 banks)
  03h - 256KByte (16 banks)
  04h - 512KByte (32 banks)
  05h -   1MByte (64 banks)  - only 63 banks used by MBC1
  06h -   2MByte (128 banks) - only 125 banks used by MBC1
  07h -   4MByte (256 banks)
  52h - 1.1MByte (72 banks)
  53h - 1.2MByte (80 banks)
  54h - 1.5MByte (96 banks)
</pre></td></tr></tbody></table><br>
<b>0149 - RAM Size<br>
</b>Specifies the size of the external RAM in the cartridge (if any).<br>
<table><tbody><tr><td><pre>  00h - None
  01h - 2 KBytes
  02h - 8 Kbytes
  03h - 32 KBytes (4 banks of 8KBytes each)
</pre></td></tr></tbody></table>When using a MBC2 chip 00h must be specifie=
d in this entry, even though=20
the MBC2 includes a built-in RAM of 512 x 4 bits.<br>
<br>
<b>014A - Destination Code<br>
</b>Specifies if this version of the game is supposed to be sold in japan,=
=20
or anywhere else. Only two values are defined.<br>
<table><tbody><tr><td><pre>  00h - Japanese
  01h - Non-Japanese
</pre></td></tr></tbody></table><br>
<b>014B - Old Licensee Code<br>
</b>Specifies the games company/publisher code in range 00-FFh. A value of=
=20
33h signalizes that the New License Code in header bytes 0144-0145 is=20
used instead.<br>
(Super GameBoy functions won't work if &lt;&gt; $33.)<br>
<br>
<b>014C - Mask ROM Version number<br>
</b>Specifies the version number of the game. That is usually 00h.<br>
<br>
<b>014D - Header Checksum<br>
</b>Contains an 8 bit checksum across the cartridge header bytes 0134-014C.=
=20
The checksum is calculated as follows:<br>
<table><tbody><tr><td><pre>  x=3D0:FOR i=3D0134h TO 014Ch:x=3Dx-MEM[i]-1:NE=
XT
</pre></td></tr></tbody></table>The lower 8 bits of the result must be the =
same than the value in this=20
entry. The GAME WON'T WORK if this checksum is incorrect.<br>
<br>
<b>014E-014F - Global Checksum<br>
</b>Contains a 16 bit checksum (upper byte first) across the whole cartridg=
e=20
ROM. Produced by adding all bytes of the cartridge (except for the two=20
checksum bytes). The Gameboy doesn't verify this checksum.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"memoryb=
ankcontrollers"></a><font size=3D"+2">&nbsp;Memory Bank Controllers</font><=
/td></tr></tbody></table><br>
As the gameboys 16 bit address bus offers only limited space for ROM and=20
RAM addressing, many games are using Memory Bank Controllers (MBCs) to=20
expand the available address space by bank switching. These MBC chips=20
are located in the game cartridge (ie. not in the gameboy itself),=20
several different MBC types are available:<br>
<br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#none32kbyteromonly">None (32KBy=
te ROM only)</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#mbc1max2mbyteromandor32kbyteram=
">MBC1 (max 2MByte ROM and/or 32KByte RAM)</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#mbc2max256kbyteromand512x4bitsr=
am">MBC2 (max 256KByte ROM and 512x4 bits RAM)</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#mbc3max2mbyteromandor32kbyteram=
andtimer">MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer)</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#huc1mbcwithinfraredcontroller">=
HuC1 (MBC with Infrared Controller)</a><br>
<br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#mbctimingissues">MBC Timing Iss=
ues</a><br>
<br>
In each cartridge, the required (or preferred) MBC type should be=20
specified in byte at 0147h of the ROM. (As described in the chapter=20
about The Cartridge Header.)<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"none32k=
byteromonly"></a><font size=3D"+2">&nbsp;None (32KByte ROM only)</font></td=
></tr></tbody></table><br>
Small games of not more than 32KBytes ROM do not require a MBC chip for=20
ROM banking. The ROM is directly mapped to memory at 0000-7FFFh.=20
Optionally up to 8KByte of RAM could be connected at A000-BFFF, even=20
though that could require a tiny MBC-like circuit, but no real MBC chip.<br=
>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"mbc1max=
2mbyteromandor32kbyteram"></a><font size=3D"+2">&nbsp;MBC1 (max 2MByte ROM =
and/or 32KByte RAM)</font></td></tr></tbody></table><br>
This is the first MBC chip for the gameboy. Any newer MBC chips are=20
working similiar, so that is relative easy to upgrade a program from one=20
MBC chip to another - or even to make it compatible to several different=20
types of MBCs.<br>
<br>
Note that the memory in range 0000-7FFF is used for both reading from=20
ROM, and for writing to the MBCs Control Registers.<br>
<br>
<b>0000-3FFF - ROM Bank 00 (Read Only)<br>
</b>This area always contains the first 16KBytes of the cartridge ROM.<br>
<br>
<b>4000-7FFF - ROM Bank 01-7F (Read Only)<br>
</b>This area may contain any of the further 16KByte banks of the ROM,=20
allowing to address up to 125 ROM Banks (almost 2MByte). As described=20
below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the=20
odd amount of 125 banks.<br>
<br>
<b>A000-BFFF - RAM Bank 00-03, if any (Read/Write)<br>
</b>This area is used to address external RAM in the cartridge (if any).=20
External RAM is often battery buffered, allowing to store game positions=20
or high score tables, even if the gameboy is turned off, or if the=20
cartridge is removed from the gameboy. Available RAM sizes are: 2KByte=20
(at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K=20
banks at A000-BFFF).<br>
<br>
<b>0000-1FFF - RAM Enable (Write Only)<br>
</b>Before external RAM can be read or written, it must be enabled by=20
writing to this address space. It is recommended to disable external RAM=20
after accessing it, in order to protect its contents from damage during=20
power down of the gameboy. Usually the following values are used:<br>
<table><tbody><tr><td><pre>  00h  Disable RAM (default)
  0Ah  Enable RAM
</pre></td></tr></tbody></table>Practically any value with 0Ah in the lower=
 4 bits enables RAM, and any=20
other value disables RAM.<br>
<br>
<b>2000-3FFF - ROM Bank Number (Write Only)<br>
</b>Writing to this address space selects the lower 5 bits of the ROM Bank=
=20
Number (in range 01-1Fh). When 00h is written, the MBC translates that=20
to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be=20
always directly accessed by reading from 0000-3FFF.<br>
But (when using the register below to specify the upper ROM Bank bits),=20
the same happens for Bank 20h, 40h, and 60h. Any attempt to address=20
these ROM Banks will select Bank 21h, 41h, and 61h instead.<br>
<br>
<b>4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write =
Only)<brbr>
</brbr></b>This 2bit register can be used to select a RAM Bank in range fro=
m=20
00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank=20
number, depending on the current ROM/RAM Mode. (See below.)<br>
<br>
<b>6000-7FFF - ROM/RAM Mode Select (Write Only)<br>
</b>This 1bit Register selects whether the two bits of the above register=
=20
should be used as upper two bits of the ROM Bank, or as RAM Bank Number.<br=
>
<table><tbody><tr><td><pre>  00h =3D ROM Banking Mode (up to 8KByte RAM, 2M=
Byte ROM) (default)
  01h =3D RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)
</pre></td></tr></tbody></table>The program may freely switch between both =
modes, the only limitiation=20
is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks=20
00-1Fh can be used during Mode 1.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"mbc2max=
256kbyteromand512x4bitsram"></a><font size=3D"+2">&nbsp;MBC2 (max 256KByte =
ROM and 512x4 bits RAM)</font></td></tr></tbody></table><br>
<b>0000-3FFF - ROM Bank 00 (Read Only)<br>
</b>Same as for MBC1.<br>
<br>
<b>4000-7FFF - ROM Bank 01-0F (Read Only)<br>
</b>Same as for MBC1, but only a total of 16 ROM banks is supported.<br>
<br>
<b>A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)<br>
</b>The MBC2 doesn't support external RAM, instead it includes 512x4 bits o=
f=20
built-in RAM (in the MBC2 chip itself). It still requires an external=20
battery to save data during power-off though.<br>
As the data consists of 4bit values, only the lower 4 bits of the=20
"bytes" in this memory area are used.<br>
<br>
<b>0000-1FFF - RAM Enable (Write Only)<br>
</b>The least significant bit of the upper address byte must be zero to=20
enable/disable cart RAM. For example the following addresses can be used=20
to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ...,=20
1E00-1EFF.<br>
The suggested address range to use for MBC2 ram enable/disable is=20
0000-00FF.<br>
<br>
<b>2000-3FFF - ROM Bank Number (Write Only)<br>
</b>Writing a value (XXXXBBBB - X =3D Don't cares, B =3D bank select bits) =
into=20
2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.<br>
<br>
The least significant bit of the upper address byte must be one to=20
select a ROM bank. For example the following addresses can be used to=20
select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.<br>
The suggested address range to use for MBC2 rom bank selection is=20
2100-21FF.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"mbc3max=
2mbyteromandor32kbyteramandtimer"></a><font size=3D"+2">&nbsp;MBC3 (max 2MB=
yte ROM and/or 32KByte RAM and Timer)</font></td></tr></tbody></table><br>
Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM=20
(4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The=20
RTC requires an external 32.768 kHz Quartz Oscillator, and an external=20
battery (if it should continue to tick when the gameboy is turned off).<br>
<br>
<b>0000-3FFF - ROM Bank 00 (Read Only)<br>
</b>Same as for MBC1.<br>
<br>
<b>4000-7FFF - ROM Bank 01-7F (Read Only)<br>
</b>Same as for MBC1, except that accessing banks 20h, 40h, and 60h is=20
supported now.<br>
<br>
<b>A000-BFFF - RAM Bank 00-03, if any (Read/Write)<br>
A000-BFFF - RTC Register 08-0C (Read/Write)<br>
</b>Depending on the current Bank Number/RTC Register selection (see below)=
,=20
this memory space is used to access an 8KByte external RAM Bank, or a=20
single RTC Register.<br>
<br>
<b>0000-1FFF - RAM and Timer Enable (Write Only)<br>
</b>Mostly the same as for MBC1, a value of 0Ah will enable reading and=20
writing to external RAM - and to the RTC Registers! A value of 00h will=20
disable either.<br>
<br>
<b>2000-3FFF - ROM Bank Number (Write Only)<br>
</b>Same as for MBC1, except that the whole 7 bits of the RAM Bank Number=
=20
are written directly to this address. As for the MBC1, writing a value=20
of 00h, will select Bank 01h instead. All other values 01-7Fh select the=20
corresponding ROM Banks.<br>
<br>
<b>4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)<br>
</b>As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h=
=20
maps the corresponding external RAM Bank (if any) into memory at=20
A000-BFFF.<br>
When writing a value of 08h-0Ch, this will map the corresponding RTC=20
register into memory at A000-BFFF. That register could then be=20
read/written by accessing any address in that area, typically that is=20
done by using address A000.<br>
<br>
<b>6000-7FFF - Latch Clock Data (Write Only)<br>
</b>When writing 00h, and then 01h to this register, the current time=20
becomes latched into the RTC registers. The latched data will not change=20
until it becomes latched again, by repeating the write 00h-&gt;01h=20
procedure.<br>
This is supposed for &lt;reading&gt; from the RTC registers. It is proof to=
=20
read the latched (frozen) time from the RTC registers, while the clock=20
itself continues to tick in background.<br>
<br>
<b>The Clock Counter Registers<br>
</b><table><tbody><tr><td><pre>  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=3DActive, 1=3DStop Timer)
        Bit 7  Day Counter Carry Bit (1=3DCounter Overflow)
</pre></td></tr></tbody></table>The Halt Flag is supposed to be set before =
&lt;writing&gt; to the RTC=20
Registers.<br>
<br>
<b>The Day Counter<br>
</b>The total 9 bits of the Day Counter allow to count days in range from=
=20
0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value=20
overflows. In that case the Carry Bit remains set until the program does=20
reset it.<br>
Note that you can store an offset to the Day Counter in battery RAM. For=20
example, every time you read a non-zero Day Counter, add this Counter to=20
the offset in RAM, and reset the Counter to zero. This method allows to=20
count any number of days, making your program Year-10000-Proof, provided=20
that the cartridge gets used at least every 511 days.<br>
<br>
<b>Delays<br>
</b>When accessing the RTC Registers it is recommended to execute a 4ms=20
delay (4 Cycles in Normal Speed Mode) between the separate accesses.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"huc1mbc=
withinfraredcontroller"></a><font size=3D"+2">&nbsp;HuC1 (MBC with Infrared=
 Controller)</font></td></tr></tbody></table><br>
This controller (made by Hudson Soft) appears to be very similar to an=20
MBC1 with the main difference being that it supports infrared LED input=20
/ output. (Similiar to the infrared port that has been later invented in=20
CGBs.)<br>
<br>
The Japanese cart "Fighting Phoenix" (internal cart name: SUPER B DAMAN)=20
is known to contain this chip.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"mbctimi=
ngissues"></a><font size=3D"+2">&nbsp;MBC Timing Issues</font></td></tr></t=
body></table><br>
<b>Using MBCs with CGB Double Speed Mode<br>
</b>The MBC5 has been designed to support CGB Double Speed Mode.<br>
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast=20
enough in that mode. If so, it might be nethertheless possible to use=20
Double Speed during periods which use only code and data which is=20
located in internal RAM.<br>
However, despite of the above, my own good old selfmade MBC1-EPROM card=20
appears to work stable and fine even in Double Speed Mode though.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"gamegen=
iesharkcheats"></a><font size=3D"+2">&nbsp;Gamegenie/Shark Cheats</font></t=
d></tr></tbody></table><br>
Game Shark and Gamegenie are external cartridge adapters that can be=20
plugged between the gameboy and the actual game cartridge. Hexadecimal=20
codes can be then entered for specific games, typically providing things=20
like Infinite Sex, 255 Cigarettes, or Starting directly in Wonderland=20
Level PRO, etc.<br>
<br>
<b>Gamegenie (ROM patches)<br>
</b>Gamegenie codes consist of nine-digit hex numbers, formatted as=20
ABC-DEF-GHI, the meaning of the separate digits is:<br>
<table><tbody><tr><td><pre>  AB    New data
  FCDE  Memory address, XORed by 0F000h
  GI    Old data, XORed by 0BAh and rotated left by two
  H     Don't know, maybe checksum and/or else
</pre></td></tr></tbody></table>The address should be located in ROM area 0=
000h-7FFFh, the adapter=20
permanently compares address/old data with address/data being read by=20
the game, and replaces that data by new data if necessary. That method=20
(more or less) prohibits unwanted patching of wrong memory banks.=20
Eventually it is also possible to patch external RAM ?<br>
Newer devices reportedly allow to specify only the first six digits=20
(optionally). As far as I rememeber, around three or four codes can be=20
used simultaneously.<br>
<br>
<b>Game Shark (RAM patches)<br>
</b>Game Shark codes consist of eight-digit hex numbers, formatted as=20
ABCDEFGH, the meaning of the separate digits is:<br>
<table><tbody><tr><td><pre>  AB    External RAM bank number
  CD    New Data
  GHEF  Memory Address (internal or external RAM, A000-DFFF)
</pre></td></tr></tbody></table>As far as I understand, patching is impleme=
nt by hooking the original=20
VBlank interrupt handler, and re-writing RAM values each frame. The=20
downside is that this method steals some CPU time, also, it cannot be=20
used to patch program code in ROM.<br>
As far as I rememeber, somewhat 10-25 codes can be used simultaneously.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"powerup=
sequence"></a><font size=3D"+2">&nbsp;Power Up Sequence</font></td></tr></t=
body></table><br>
When the GameBoy is powered up, a 256 byte program starting at memory=20
location 0 is executed. This program is located in a ROM inside the=20
GameBoy. The first thing the program does is read the cartridge=20
locations from $104 to $133 and place this graphic of a Nintendo logo on=20
the screen at the top. This image is then scrolled until it is in the=20
middle of the screen. Two musical notes are then played on the internal=20
speaker. Again, the cartridge locations $104 to $133 are read but this=20
time they are compared with a table in the internal rom. If any byte=20
fails to compare, then the GameBoy stops comparing bytes and simply=20
halts all operations. If all locations compare the same, then the=20
GameBoy starts adding all of the bytes in the cartridge from $134 to=20
$14d. A value of 25 decimal is added to this total. If the least=20
significant byte of the result is a not a zero, then the GameBoy will=20
stop doing anything. If it is a zero, then the internal ROM is disabled=20
and cartridge program execution begins at location $100 with the=20
following register values:<br>
<br>
<table><tbody><tr><td><pre>   AF=3D$01B0
   BC=3D$0013
   DE=3D$00D8
   HL=3D$014D
   Stack Pointer=3D$FFFE
   [$FF05] =3D $00   ; TIMA
   [$FF06] =3D $00   ; TMA
   [$FF07] =3D $00   ; TAC
   [$FF10] =3D $80   ; NR10
   [$FF11] =3D $BF   ; NR11
   [$FF12] =3D $F3   ; NR12
   [$FF14] =3D $BF   ; NR14
   [$FF16] =3D $3F   ; NR21
   [$FF17] =3D $00   ; NR22
   [$FF19] =3D $BF   ; NR24
   [$FF1A] =3D $7F   ; NR30
   [$FF1B] =3D $FF   ; NR31
   [$FF1C] =3D $9F   ; NR32
   [$FF1E] =3D $BF   ; NR33
   [$FF20] =3D $FF   ; NR41
   [$FF21] =3D $00   ; NR42
   [$FF22] =3D $00   ; NR43
   [$FF23] =3D $BF   ; NR30
   [$FF24] =3D $77   ; NR50
   [$FF25] =3D $F3   ; NR51
   [$FF26] =3D $F1-GB, $F0-SGB ; NR52
   [$FF40] =3D $91   ; LCDC
   [$FF42] =3D $00   ; SCY
   [$FF43] =3D $00   ; SCX
   [$FF45] =3D $00   ; LYC
   [$FF47] =3D $FC   ; BGP
   [$FF48] =3D $FF   ; OBP0
   [$FF49] =3D $FF   ; OBP1
   [$FF4A] =3D $00   ; WY
   [$FF4B] =3D $00   ; WX
   [$FFFF] =3D $00   ; IE
</pre></td></tr></tbody></table><br>
It is not a good idea to assume the above values will always exist. A=20
later version GameBoy could contain different values than these at=20
reset. Always set these registers on reset rather than assume they are=20
as above.<br>
<br>
Please note that GameBoy internal RAM on power up contains random data.=20
All of the GameBoy emulators tend to set all RAM to value $00 on entry.<br>
<br>
Cart RAM the first time it is accessed on a real GameBoy contains random=20
data. It will only contain known data if the GameBoy code initializes it=20
to some value.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"reducin=
gpowerconsumption"></a><font size=3D"+2">&nbsp;Reducing Power Consumption</=
font></td></tr></tbody></table><br>
The following can be used to recude the power consumption of the=20
gameboy, and to extend the life of the batteries.<br>
<br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#pwrusingthehaltinstruction">PWR=
 Using the HALT Instruction</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#pwrusingthestopinstruction">PWR=
 Using the STOP Instruction</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#pwrdisabelingthesoundcontroller=
">PWR Disabeling the Sound Controller</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#pwrnotusingcgbdoublespeedmode">=
PWR Not using CGB Double Speed Mode</a><br>
<a href=3D"http://bgb.bircd.org/pandocs.htm#pwrusingtheskills">PWR Using th=
e Skills</a><br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"pwrusin=
gthehaltinstruction"></a><font size=3D"+2">&nbsp;PWR Using the HALT Instruc=
tion</font></td></tr></tbody></table><br>
It is recommended that the HALT instruction be used whenever possible to=20
reduce power consumption &amp; extend the life of the batteries. This=20
command stops the system clock reducing the power consumption of both=20
the CPU and ROM.<br>
<br>
The CPU will remain suspended until an interrupt occurs at which point=20
the interrupt is serviced and then the instruction immediately following=20
the HALT is executed.<br>
<br>
Depending on how much CPU time is required by a game, the HALT=20
instruction can extend battery life anywhere from 5 to 50% or possibly=20
more.<br>
<br>
When waiting for a vblank event, this would be a BAD example:<br>
<table><tbody><tr><td><pre>  @@wait:
   ld   a,(0FF44h)      ;LY
   cp   a,144
   jr   nz,@@wait
</pre></td></tr></tbody></table><br>
A better example would be a procedure as shown below. In this case the=20
vblank interrupt must be enabled, and your vblank interrupt procedure=20
must set vblank_flag to a non-zero value.<br>
<table><tbody><tr><td><pre>   ld   hl,vblank_flag  ;hl=3Dpointer to vblank_=
flag
   xor  a               ;a=3D0
  @@wait:               ;wait...
   halt                 ;suspend CPU - wait for ANY interrupt
   cp   a,(hl)          ;vblank flag still zero?
   jr   z,@@wait        ;wait more if zero
   ld   (hl),a          ;set vblank_flag back to zero
</pre></td></tr></tbody></table>The vblank_flag is used to determine whethe=
r the HALT period has been=20
terminated by a vblank interrupt, or by another interrupt. In case that=20
your program has all other interrupts disabled, then it would be proof=20
to replace the above procedure by a single HALT instruction.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"pwrusin=
gthestopinstruction"></a><font size=3D"+2">&nbsp;PWR Using the STOP Instruc=
tion</font></td></tr></tbody></table><br>
The STOP instruction is intended to switch the gameboy into VERY low=20
power standby mode. For example, a program may use this feature when it=20
hasn't sensed keyboard input for a longer period (assuming that somebody=20
forgot to turn off the gameboy).<br>
<br>
Before invoking STOP, it might be required to disable Sound and Video=20
manually (as well as IR-link port in CGB). Much like HALT, the STOP=20
state is terminated by interrupt events - in this case this would be=20
commonly a joypad interrupt. The joypad register might be required to be=20
prepared for STOP either.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"pwrdisa=
belingthesoundcontroller"></a><font size=3D"+2">&nbsp;PWR Disabeling the So=
und Controller</font></td></tr></tbody></table><br>
If your programs doesn't use sound at all (or during some periods) then=20
write 00h to register FF26 to save 16% or more on GB power consumption.<br>
Sound can be turned back on by writing 80h to the same register, all=20
sound registers must be then re-initialized.<br>
When the gameboy becomes turned on, sound is enabled by default, and=20
must be turned off manually when not used.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"pwrnotu=
singcgbdoublespeedmode"></a><font size=3D"+2">&nbsp;PWR Not using CGB Doubl=
e Speed Mode</font></td></tr></tbody></table><br>
Because CGB Double Speed mode consumes more power, it'd be recommended=20
to use normal speed when possible.<br>
There's limited ability to switch between both speeds, for example, a=20
game might use normal speed in the title screen, and double speed in the=20
game, or vice versa.<br>
However, during speed switch the display collapses for a short moment,=20
so that it'd be no good idea to alter speeds within active game or title=20
screen periods.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"pwrusin=
gtheskills"></a><font size=3D"+2">&nbsp;PWR Using the Skills</font></td></t=
r></tbody></table><br>
Most of the above power saving methods will produce best results when=20
using efficient and tight assembler code which requires as less CPU=20
power as possible. Thus, experienced old-school programmers will=20
(hopefully) produce lower power consumption, as than HLL-programming=20
teenagers, for example.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"spriter=
ambug"></a><font size=3D"+2">&nbsp;Sprite RAM Bug</font></td></tr></tbody><=
/table><br>
There is a flaw in the GameBoy hardware that causes trash to be written=20
to OAM RAM if the following commands are used while their 16-bit content=20
is in the range of $FE00 to $FEFF:<br>
<table><tbody><tr><td><pre>  inc rr        dec rr          ;rr =3D bc,de, o=
r hl
  ldi a,(hl)    ldd a,(hl)
  ldi (hl),a    ldd (hl),a
</pre></td></tr></tbody></table>Only sprites 1 &amp; 2 ($FE00 &amp; $FE04) =
are not affected by these=20
instructions.<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"externa=
lconnectors"></a><font size=3D"+2">&nbsp;External Connectors</font></td></t=
r></tbody></table><br>
<b>Cartridge Slot<br>
</b><table><tbody><tr><td><pre>  Pin   Name    Expl.
  1     VDD     Power Supply +5V DC
  2     PHI     System Clock
  3     /WR     Write
  4     /RD     Read
  5     /CS     Chip Select
  6-21  A0-A15  Address Lines
  22-29 D0-D7   Data Lines
  30    /RES    Reset signal
  31    VIN     External Sound Input
  32    GND     Ground
</pre></td></tr></tbody></table><br>
<b>Link Port<br>
</b>Pin numbers are arranged as 2,4,6 in upper row, 1,3,5 un lower row;=20
outside view of gameboy socket; flat side of socket upside.<br>
Colors as used in most or all standard link cables, because SIN and SOUT=20
are crossed, colors Red and Orange are exchanged at one cable end.<br>
<table><tbody><tr><td><pre>  Pin Name Color  Expl.
  1   VCC  -      +5V DC
  2   SOUT red    Data Out
  3   SIN  orange Data In
  4   P14  -      Not used
  5   SCK  green  Shift Clock
  6   GND  blue   Ground
</pre></td></tr></tbody></table>Note: The original gameboy used larger plug=
s (unlike pocket gameboys and=20
newer), linking between older/newer gameboys is possible by using cables=20
with one large and one small plug though.<br>
<br>
<b>Stereo Sound Connector (3.5mm, female)<br>
</b><table><tbody><tr><td><pre>  Pin     Expl.
  Tip     Sound Left
  Middle  Sound Right
  Base    Ground
</pre></td></tr></tbody></table><br>
<b>External Power Supply<br>
</b>...<br>
<br>
<br>
<br>
<table width=3D"100%"><tbody><tr bgcolor=3D"#cccccc"><td><a name=3D"end"></=
a><font size=3D"+2">&nbsp;END</font></td></tr></tbody></table>
=1A</body></html>
------MultipartBoundary--ewUgoYUz5435X0uE3WhRz0o2tZr2o3Hg3oXqlvE3c5------
